Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-18T01:14:04+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/2f53bc7c957f805c6af9b39b4c36737abe0599c1

iCal export - separate component properties
iCal export: Factor-out all event components from ``ICalendarEventComponent.to_ical`` method into separate properties, so that individual properties can be easier overloaded in subclasses.

Files changed:
M CHANGES.rst
M plone/app/event/ical/exporter.py

diff --git a/CHANGES.rst b/CHANGES.rst
index c6b6dcc7..73a1abdb 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -23,6 +23,8 @@ Bug fixes:
 
 3.0.7 (2017-11-24)
 ------------------
+- iCal export: Factor-out all event components from ``ICalendarEventComponent.to_ical`` method into separate properties, so that individual properties can be easier overloaded in subclasses.
+  [thet]
 
 Bug fixes:
 
diff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py
index 446101de..bb30de5f 100644
--- a/plone/app/event/ical/exporter.py
+++ b/plone/app/event/ical/exporter.py
@@ -195,35 +195,65 @@ class ICalendarEventComponent(object):
 
     def __init__(self, context):
         self.context = context
-        self.event = IEventAccessor(context)
-
-    def to_ical(self):
-        ical = icalendar.Event()
-        event = self.event
-
-        # TODO: event.text
-
-        # must be in utc
-        ical.add('dtstamp', utc(datetime.now()))
-        ical.add('created', utc(event.created))
-        ical.add('last-modified', utc(event.last_modified))
-
-        if event.sync_uid:
+        self.event = IEventAccessor(self.context)
+        self.ical = icalendar.Event()
+
+    @property
+    def dtstamp(self):
+        # must be in uc
+        return utc(datetime.now())
+
+    @property
+    def created(self):
+        # must be in uc
+        return utc(self.event.created)
+
+    @property
+    def last_modified(self):
+        # must be in uc
+        return utc(self.event.last_modified)
+
+    @property
+    def uid(self):
+        if self.event.sync_uid:
             # Re-Use existing icalendar event UID
-            ical.add('uid', event.sync_uid)
-        else:
-            # Else, use plone.uuid
-            ical.add('uid', event.uid)
+            return self.event.sync_uid
+        # Else, use plone.uuid
+        return self.event.uid
 
-        ical.add('url', event.url)
+    @property
+    def url(self):
+        return self.event.url
 
-        ical.add('summary', event.title)
+    @property
+    def summary(self):
+        return self.event.title
 
-        if event.description:
-            ical.add('description', event.description)
+    @property
+    def description(self):
+        return self.event.description
 
-        if event.whole_day:
-            ical.add('dtstart', event.start.date())
+    @property
+    def dtstart(self):
+        if self.event.whole_day:
+            # RFC5545, 3.6.1
+            # For cases where a "VEVENT" calendar component
+            # specifies a "DTSTART" property with a DATE value type but no
+            # "DTEND" nor "DURATION" property, the event's duration is taken to
+            # be one day.
+            return self.event.start.date()
+
+        # Normal case + Open End case:
+        # RFC5545, 3.6.1
+        # For cases where a "VEVENT" calendar component
+        # specifies a "DTSTART" property with a DATE-TIME value type but no
+        # "DTEND" property, the event ends on the same calendar date and
+        # time of day specified by the "DTSTART" property.
+        return self.event.start
+
+    @property
+    def dtend(self):
+        if self.event.whole_day:
             # RFC5545, 3.6.1
             # For cases where a "VEVENT" calendar component
             # specifies a "DTSTART" property with a DATE value type but no
@@ -244,55 +274,69 @@ def to_ical(self):
             # -appointments-in-ics-files
             # http://icalevents.com/1778-all-day-events-adding-a-day-or-not/
             # http://www.innerjoin.org/iCalendar/all-day-events.html
-            ical.add('dtend', event.end.date() + timedelta(days=1))
-        elif event.open_end:
+            return self.event.end.date() + timedelta(days=1)
+
+        elif self.event.open_end:
             # RFC5545, 3.6.1
             # For cases where a "VEVENT" calendar component
             # specifies a "DTSTART" property with a DATE-TIME value type but no
             # "DTEND" property, the event ends on the same calendar date and
             # time of day specified by the "DTSTART" property.
-            ical.add('dtstart', event.start)
-        else:
-            ical.add('dtstart', event.start)
-            ical.add('dtend', event.end)
-
-        if event.recurrence and not IOccurrence.providedBy(self.context):
-            for recdef in event.recurrence.split():
-                prop, val = recdef.split(':')
-                if prop == 'RRULE':
-                    ical.add(prop, icalendar.prop.vRecur.from_ical(val))
-                elif prop in ('EXDATE', 'RDATE'):
-                    factory = icalendar.prop.vDDDLists
-
-                    # localize ex/rdate
-                    # TODO: should better already be localized by event object
-                    tzid = event.timezone
-                    if isinstance(tzid, tuple):
-                        tzid = tzid[0]
-                    # get list of datetime values from ical string
-                    try:
-                        dtlist = factory.from_ical(val, timezone=tzid)
-                    except ValueError:
-                        # TODO: caused by a bug in plone.formwidget.recurrence,
-                        # where the recurrencewidget or plone.event fails with
-                        # COUNT=1 and a extra RDATE.
-                        # TODO: REMOVE this workaround, once this failure is
-                        # fixed in recurrence widget.
-                        continue
-                    ical.add(prop, dtlist)
-
-        if event.location:
-            ical.add('location', event.location)
-
+            return None
+
+        return self.event.end
+
+    @property
+    def recurrence(self):
+        ret = []
+        if not self.event.recurrence or IOccurrence.providedBy(self.context):
+            return ret
+
+        for recdef in self.event.recurrence.split():
+            prop, val = recdef.split(':')
+            if prop == 'RRULE':
+                ret.append((prop, icalendar.prop.vRecur.from_ical(val)))
+            elif prop in ('EXDATE', 'RDATE'):
+                factory = icalendar.prop.vDDDLists
+
+                # localize ex/rdate
+                # TODO: should better already be localized by event object
+                tzid = self.event.timezone
+                if isinstance(tzid, tuple):
+                    tzid = tzid[0]
+                # get list of datetime values from ical string
+                try:
+                    dtlist = factory.from_ical(val, timezone=tzid)
+                except ValueError:
+                    # TODO: caused by a bug in plone.formwidget.recurrence,
+                    # where the recurrencewidget or plone.event fails with
+                    # COUNT=1 and a extra RDATE.
+                    # TODO: REMOVE this workaround, once this failure is
+                    # fixed in recurrence widget.
+                    continue
+                ret.append((prop, dtlist))
+
+        return ret
+
+    @property
+    def location(self):
+        return self.event.location
+
+    @property
+    def attendee(self):
         # TODO: revisit and implement attendee export according to RFC
-        if event.attendees:
-            for attendee in event.attendees:
-                att = icalendar.prop.vCalAddress(attendee)
-                att.params['cn'] = icalendar.prop.vText(attendee)
-                att.params['ROLE'] = icalendar.prop.vText('REQ-PARTICIPANT')
-                ical.add('attendee', att)
-
+        ret = []
+        for attendee in self.event.attendees or []:
+            att = icalendar.prop.vCalAddress(attendee)
+            att.params['cn'] = icalendar.prop.vText(attendee)
+            att.params['ROLE'] = icalendar.prop.vText('REQ-PARTICIPANT')
+            ret.append(att)
+        return ret
+
+    @property
+    def contact(self):
         cn = []
+        event = self.event
         if event.contact_name:
             cn.append(event.contact_name)
         if event.contact_phone:
@@ -301,14 +345,44 @@ def to_ical(self):
             cn.append(event.contact_email)
         if event.event_url:
             cn.append(event.event_url)
-        if cn:
-            ical.add('contact', u', '.join(cn))
 
-        if event.subjects:
-            for subject in event.subjects:
-                ical.add('categories', subject)
+        return u', '.join(cn)
+
+    @property
+    def categories(self):
+        return self.event.subjects or []
+
+    def ical_add(self, prop, val, multiple=True):
+        if not val:
+            return
+        if (multiple and not isinstance(val, (list, tuple))) or not multiple:
+            val = [val]
+        for _val in val:
+            self.ical.add(prop, _val)
+
+    def to_ical(self):
+        # TODO: event.text
 
-        return ical
+        ical_add = self.ical_add
+        ical_add('dtstamp', self.dtstamp)
+        ical_add('created', self.created)
+        ical_add('last-modified', self.last_modified)
+        ical_add('uid', self.uid)
+        ical_add('url', self.url)
+        ical_add('summary', self.summary)
+        ical_add('description', self.description)
+        ical_add('dtstart', self.dtstart)
+        ical_add('dtend', self.dtend)
+
+        for key, val in self.recurrence:
+            ical_add(key, val, multiple=False)
+
+        ical_add('location', self.location)
+        ical_add('attendee', self.attendee)
+        ical_add('contact', self.contact)
+        ical_add('categories', self.categories)
+
+        return self.ical
 
 
 class EventsICal(BrowserView):


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-18T01:14:04+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/1c1fdedbff33097a0b0d65caabb8ea1b49d263a0

iCal export: Add ``geo`` for (lat, lng) geolocation coordinates.
This method is not implemented and can be used by addons to provide that feature.

Files changed:
M CHANGES.rst
M plone/app/event/ical/exporter.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 73a1abdb..dd91dac9 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -23,6 +23,10 @@ Bug fixes:
 
 3.0.7 (2017-11-24)
 ------------------
+- iCal export: Add ``geo`` for (lat, lng) geolocation coordinates.
+  This method is not implemented and can be used by addons to provide that feature.
+  [thet]
+
 - iCal export: Factor-out all event components from ``ICalendarEventComponent.to_ical`` method into separate properties, so that individual properties can be easier overloaded in subclasses.
   [thet]
 
diff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py
index bb30de5f..7cfbb188 100644
--- a/plone/app/event/ical/exporter.py
+++ b/plone/app/event/ical/exporter.py
@@ -352,6 +352,12 @@ def contact(self):
     def categories(self):
         return self.event.subjects or []
 
+    @property
+    def geo(self):
+        """Not implemented.
+        """
+        return
+
     def ical_add(self, prop, val, multiple=True):
         if not val:
             return
@@ -381,6 +387,7 @@ def to_ical(self):
         ical_add('attendee', self.attendee)
         ical_add('contact', self.contact)
         ical_add('categories', self.categories)
+        ical_add('geo', self.geo, multiple=False)
 
         return self.ical
 


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-18T01:14:04+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/9507214d5a95d535fd3a751a6e5064450fa8c1cc

iCal export: Support property parameters.

Files changed:
M CHANGES.rst
M plone/app/event/ical/exporter.py

diff --git a/CHANGES.rst b/CHANGES.rst
index dd91dac9..0cba967e 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -23,6 +23,9 @@ Bug fixes:
 
 3.0.7 (2017-11-24)
 ------------------
+- iCal export: Support property parameters.
+  [thet]
+
 - iCal export: Add ``geo`` for (lat, lng) geolocation coordinates.
   This method is not implemented and can be used by addons to provide that feature.
   [thet]
diff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py
index 7cfbb188..c11ae37f 100644
--- a/plone/app/event/ical/exporter.py
+++ b/plone/app/event/ical/exporter.py
@@ -201,37 +201,37 @@ def __init__(self, context):
     @property
     def dtstamp(self):
         # must be in uc
-        return utc(datetime.now())
+        return {'value': utc(datetime.now())}
 
     @property
     def created(self):
         # must be in uc
-        return utc(self.event.created)
+        return {'value': utc(self.event.created)}
 
     @property
     def last_modified(self):
         # must be in uc
-        return utc(self.event.last_modified)
+        return {'value': utc(self.event.last_modified)}
 
     @property
     def uid(self):
         if self.event.sync_uid:
             # Re-Use existing icalendar event UID
-            return self.event.sync_uid
+            return {'value': self.event.sync_uid}
         # Else, use plone.uuid
-        return self.event.uid
+        return {'value': self.event.uid}
 
     @property
     def url(self):
-        return self.event.url
+        return {'value': self.event.url}
 
     @property
     def summary(self):
-        return self.event.title
+        return {'value': self.event.title}
 
     @property
     def description(self):
-        return self.event.description
+        return {'value': self.event.description}
 
     @property
     def dtstart(self):
@@ -241,7 +241,7 @@ def dtstart(self):
             # specifies a "DTSTART" property with a DATE value type but no
             # "DTEND" nor "DURATION" property, the event's duration is taken to
             # be one day.
-            return self.event.start.date()
+            return {'value': self.event.start.date()}
 
         # Normal case + Open End case:
         # RFC5545, 3.6.1
@@ -249,7 +249,7 @@ def dtstart(self):
         # specifies a "DTSTART" property with a DATE-TIME value type but no
         # "DTEND" property, the event ends on the same calendar date and
         # time of day specified by the "DTSTART" property.
-        return self.event.start
+        return {'value': self.event.start}
 
     @property
     def dtend(self):
@@ -274,7 +274,7 @@ def dtend(self):
             # -appointments-in-ics-files
             # http://icalevents.com/1778-all-day-events-adding-a-day-or-not/
             # http://www.innerjoin.org/iCalendar/all-day-events.html
-            return self.event.end.date() + timedelta(days=1)
+            return {'value': self.event.end.date() + timedelta(days=1)}
 
         elif self.event.open_end:
             # RFC5545, 3.6.1
@@ -284,18 +284,22 @@ def dtend(self):
             # time of day specified by the "DTSTART" property.
             return None
 
-        return self.event.end
+        return {'value': self.event.end}
 
     @property
     def recurrence(self):
-        ret = []
         if not self.event.recurrence or IOccurrence.providedBy(self.context):
-            return ret
+            return None
 
+        ret = []
         for recdef in self.event.recurrence.split():
             prop, val = recdef.split(':')
             if prop == 'RRULE':
-                ret.append((prop, icalendar.prop.vRecur.from_ical(val)))
+                ret.append({
+                    'property': prop,
+                    'value': icalendar.prop.vRecur.from_ical(val)
+                })
+
             elif prop in ('EXDATE', 'RDATE'):
                 factory = icalendar.prop.vDDDLists
 
@@ -314,13 +318,16 @@ def recurrence(self):
                     # TODO: REMOVE this workaround, once this failure is
                     # fixed in recurrence widget.
                     continue
-                ret.append((prop, dtlist))
+                ret.append({
+                    'property': prop,
+                    'value': dtlist
+                })
 
         return ret
 
     @property
     def location(self):
-        return self.event.location
+        return {'value': self.event.location}
 
     @property
     def attendee(self):
@@ -331,7 +338,7 @@ def attendee(self):
             att.params['cn'] = icalendar.prop.vText(attendee)
             att.params['ROLE'] = icalendar.prop.vText('REQ-PARTICIPANT')
             ret.append(att)
-        return ret
+        return {'value': ret}
 
     @property
     def contact(self):
@@ -346,11 +353,11 @@ def contact(self):
         if event.event_url:
             cn.append(event.event_url)
 
-        return u', '.join(cn)
+        return {'value': u', '.join(cn)}
 
     @property
     def categories(self):
-        return self.event.subjects or []
+        return {'value': self.event.subjects} or None
 
     @property
     def geo(self):
@@ -358,13 +365,19 @@ def geo(self):
         """
         return
 
-    def ical_add(self, prop, val, multiple=True):
+    def ical_add(self, prop, val):
         if not val:
             return
-        if (multiple and not isinstance(val, (list, tuple))) or not multiple:
+
+        if not isinstance(val, list):
             val = [val]
+
         for _val in val:
-            self.ical.add(prop, _val)
+            assert(isinstance(_val, dict))
+            prop = _val.get('property', prop)
+            value = _val['value']
+            params = _val.get('parameters', None)
+            self.ical.add(prop, value, params)
 
     def to_ical(self):
         # TODO: event.text
@@ -379,15 +392,12 @@ def to_ical(self):
         ical_add('description', self.description)
         ical_add('dtstart', self.dtstart)
         ical_add('dtend', self.dtend)
-
-        for key, val in self.recurrence:
-            ical_add(key, val, multiple=False)
-
+        ical_add(None, self.recurrence)  # property key set via val
         ical_add('location', self.location)
         ical_add('attendee', self.attendee)
         ical_add('contact', self.contact)
         ical_add('categories', self.categories)
-        ical_add('geo', self.geo, multiple=False)
+        ical_add('geo', self.geo)
 
         return self.ical
 


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-18T01:14:04+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/0df4bf68e6837eed25e250d595a647364df29793

fix ical subjects export

Files changed:
M plone/app/event/ical/exporter.py

diff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py
index c11ae37f..25c298e2 100644
--- a/plone/app/event/ical/exporter.py
+++ b/plone/app/event/ical/exporter.py
@@ -357,7 +357,10 @@ def contact(self):
 
     @property
     def categories(self):
-        return {'value': self.event.subjects} or None
+        ret = []
+        for cat in self.event.subjects or []:
+            ret.append({'value': cat})
+        return ret or None
 
     @property
     def geo(self):


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-18T01:14:04+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/8c5961d0cc06b8f67883ea6a5e3ba369890cd1fd

ical export: dont add if value is empty

Files changed:
M plone/app/event/ical/exporter.py

diff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py
index 25c298e2..276ea30d 100644
--- a/plone/app/event/ical/exporter.py
+++ b/plone/app/event/ical/exporter.py
@@ -379,6 +379,9 @@ def ical_add(self, prop, val):
             assert(isinstance(_val, dict))
             prop = _val.get('property', prop)
             value = _val['value']
+            if not value:
+                continue
+            prop = _val.get('property', prop)
             params = _val.get('parameters', None)
             self.ical.add(prop, value, params)
 


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-18T01:14:04+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/b02f7445edd140c497160177d8d56b6d0909367f

ical export: More response headers.

Files changed:
M CHANGES.rst
M plone/app/event/ical/exporter.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 0cba967e..06c88950 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -31,6 +31,11 @@ Bug fixes:
   [thet]
 
 - iCal export: Factor-out all event components from ``ICalendarEventComponent.to_ical`` method into separate properties, so that individual properties can be easier overloaded in subclasses.
+- iCal export:
+  - More response headers.
+  - Support property parameters.
+  - Add ``geo`` for (lat, lng) geolocation coordinates. This method is not implemented and can be used by addons to provide that feature.
+  - Factor-out all event components from ``ICalendarEventComponent.to_ical`` method into separate properties, so that individual properties can be easier overloaded in subclasses.
   [thet]
 
 Bug fixes:
diff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py
index 276ea30d..661f79bd 100644
--- a/plone/app/event/ical/exporter.py
+++ b/plone/app/event/ical/exporter.py
@@ -377,7 +377,6 @@ def ical_add(self, prop, val):
 
         for _val in val:
             assert(isinstance(_val, dict))
-            prop = _val.get('property', prop)
             value = _val['value']
             if not value:
                 continue
@@ -417,10 +416,13 @@ def get_ical_string(self):
         return cal.to_ical()
 
     def __call__(self):
-        name = '%s.ics' % self.context.getId()
-        self.request.RESPONSE.setHeader('Content-Type', 'text/calendar')
-        self.request.RESPONSE.setHeader(
+        ical = self.get_ical_string()
+        name = '{0}.ics'.format(self.context.getId())
+        self.request.response.setHeader('Content-Type', 'text/calendar')
+        self.request.response.setHeader(
             'Content-Disposition',
-            'attachment; filename="%s"' % name
+            'attachment; filename="{0}"'.format(name)
         )
-        self.request.RESPONSE.write(self.get_ical_string())
+        self.request.response.setHeader('Content-Length', len(ical))
+        self.request.response.setHeader('Pragma', 'no-cache')
+        self.request.response.write(ical)


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-18T01:14:04+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/4f7dab87bd26bc8c97dd0630956a790b6992b200

Add rel=nofollow to ical export links for robots to not download them.

Files changed:
M CHANGES.rst
M plone/app/event/browser/event_listing.pt
M plone/app/event/browser/event_summary.pt

diff --git a/CHANGES.rst b/CHANGES.rst
index 06c88950..e0eaa3ac 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -31,6 +31,9 @@ Bug fixes:
   [thet]
 
 - iCal export: Factor-out all event components from ``ICalendarEventComponent.to_ical`` method into separate properties, so that individual properties can be easier overloaded in subclasses.
+- Add ``rel="nofollow"`` to ical export links for robots to not download them.
+  [thet]
+
 - iCal export:
   - More response headers.
   - Support property parameters.
diff --git a/plone/app/event/browser/event_listing.pt b/plone/app/event/browser/event_listing.pt
index f54e74c8..7f32b9e0 100644
--- a/plone/app/event/browser/event_listing.pt
+++ b/plone/app/event/browser/event_listing.pt
@@ -106,7 +106,7 @@
             </li>
 
             <li>
-              <a class="event_ical"
+              <a class="event_ical" rel="nofollow"
                   tal:define="portal_url context/@@plone_portal_state/portal_url;"
                   tal:attributes="href string:${data/url}/ics_view"
                   title="Download this event in iCal format"
diff --git a/plone/app/event/browser/event_summary.pt b/plone/app/event/browser/event_summary.pt
index 7eb538c2..4fc53f18 100644
--- a/plone/app/event/browser/event_summary.pt
+++ b/plone/app/event/browser/event_summary.pt
@@ -120,7 +120,7 @@
         <strong i18n:translate="heading_add_to_calendar">Add event to calendar</strong>
         <tal:span tal:define="here_url context/@@plone_context_state/object_url;
                         portal_url context/@@plone_portal_state/portal_url;">
-          <a href="#"
+          <a href="#" rel="nofollow"
              tal:attributes="href string:$here_url/ics_view"
              title="Download this event in iCal format"
              i18n:attributes="title title_add_to_ical;">


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-18T01:14:04+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/2887fe5a2b1289b4564a0d68c30e98179a98d5f6

iCal export: Check, if event is really an event
Check, if event is really an event before ical-exporting.
Fixes a problem when a collection mixes event and non-event like result objects.

Files changed:
M CHANGES.rst
M plone/app/event/ical/exporter.py
M plone/app/event/tests/test_icalendar.py

diff --git a/CHANGES.rst b/CHANGES.rst
index e0eaa3ac..94133f7e 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -39,6 +39,7 @@ Bug fixes:
   - Support property parameters.
   - Add ``geo`` for (lat, lng) geolocation coordinates. This method is not implemented and can be used by addons to provide that feature.
   - Factor-out all event components from ``ICalendarEventComponent.to_ical`` method into separate properties, so that individual properties can be easier overloaded in subclasses.
+  - Check, if event is really an event before ical-exporting. Fixes a problem when a collection mixes event and non-event like result objects.
   [thet]
 
 Bug fixes:
diff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py
index 661f79bd..40b11f5f 100644
--- a/plone/app/event/ical/exporter.py
+++ b/plone/app/event/ical/exporter.py
@@ -6,6 +6,7 @@
 from plone.app.event.base import RET_MODE_BRAINS
 from plone.app.event.base import default_timezone
 from plone.app.event.base import get_events
+from plone.event.interfaces import IEvent
 from plone.event.interfaces import IEventAccessor
 from plone.event.interfaces import IICalendar
 from plone.event.interfaces import IICalendarEventComponent
@@ -49,6 +50,9 @@ def construct_icalendar(context, events):
         if ICatalogBrain.providedBy(event) or\
                 IContentListingObject.providedBy(event):
             event = event.getObject()
+        if not (IEvent.providedBy(event) or IOccurrence.providedBy(event)):
+            # Must be an event.
+            continue
         acc = IEventAccessor(event)
         tz = acc.timezone
         # TODO: the standard wants each recurrence to have a valid timezone
diff --git a/plone/app/event/tests/test_icalendar.py b/plone/app/event/tests/test_icalendar.py
index c66d2a9e..437a460c 100644
--- a/plone/app/event/tests/test_icalendar.py
+++ b/plone/app/event/tests/test_icalendar.py
@@ -234,6 +234,27 @@ def test_collection_ical(self):
         icalstr = ''.join(output)
         self.assertEqual(icalstr.count('BEGIN:VEVENT'), 4)
 
+    def test_collection_all_ical(self):
+        """Test basic icalendar export from Collections, which returns not only
+        events.
+        """
+        headers, output, request = make_fake_response(self.request)
+        self.portal.collection.query = [
+            {'i': 'portal_type',
+             'o': 'plone.app.querystring.operation.selection.any',
+             'v': ['Event', 'plone.app.event.dx.event', 'Page']
+             },
+        ]
+        view = getMultiAdapter(
+            (self.portal.collection, request),
+            name='ics_view'
+        )
+        view()
+        self.assertEqual(len(headers), 2)
+        self.assertEqual(headers['Content-Type'], 'text/calendar')
+        icalstr = ''.join(output)
+        self.assertEqual(icalstr.count('BEGIN:VEVENT'), 4)
+
 
 class TestIcalImportDX(unittest.TestCase):
     layer = PAEventDX_FUNCTIONAL_TESTING


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-18T01:14:04+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/00d6208ef542f0f25691b2be4f26207f4e5abf54

Raise AttributeError when attempting to index an empty location attribute value.

Files changed:
M CHANGES.rst
M plone/app/event/dx/behaviors.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 94133f7e..3d4393b3 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -15,14 +15,13 @@ New features:
 
 Bug fixes:
 
-- fallback search base URL for calendar/event portlets to NavigationRoot [petschki]
+- *add item here*
 
 - Fix portlet get_calendar_url with unicode search_base.
   [bsuttor]
 
+New features:
 
-3.0.7 (2017-11-24)
-------------------
 - iCal export: Support property parameters.
   [thet]
 
@@ -44,6 +43,17 @@ Bug fixes:
 
 Bug fixes:
 
+- Raise ``AttributeError`` when attempting to index an empty location attribute value.
+  [thet]
+
+- fallback search base URL for calendar/event portlets to NavigationRoot [petschki]
+
+
+3.0.7 (2017-11-24)
+------------------
+
+Bug fixes:
+
 - Fixed check for events iterable in Zope 4. [davisagli]
 
 
diff --git a/plone/app/event/dx/behaviors.py b/plone/app/event/dx/behaviors.py
index 7d3bcc5d..9091cfc3 100644
--- a/plone/app/event/dx/behaviors.py
+++ b/plone/app/event/dx/behaviors.py
@@ -358,10 +358,10 @@ def end_indexer(obj):
 @indexer(IDXEvent)
 def location_indexer(obj):
     location_adapter = IEventLocation(obj, None)
-    if location_adapter:
-        return location_adapter.location
-
-    raise AttributeError
+    location = getattr(location_adapter, 'location', None)
+    if not location:
+        raise AttributeError
+    return location
 
 
 # icalendar event UID indexer


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-18T01:14:04+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/ffe6849cdf987fc45bc0272ae5fa0f4959cfc11b

Calendar import: Fix usage of sync_uid, which wasn't correctly implemented since plone.app.event 2.0.

Files changed:
M CHANGES.rst
M plone/app/event/dx/behaviors.py
M plone/app/event/ical/exporter.py
M plone/app/event/ical/importer.py
M plone/app/event/tests/test_dx_behaviors.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 3d4393b3..486189f2 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -43,6 +43,9 @@ New features:
 
 Bug fixes:
 
+- iCalendar import: Fix usage of ``sync_uid``, which wasn't correctly implemented since plone.app.event 2.0.
+  [thet]
+
 - Raise ``AttributeError`` when attempting to index an empty location attribute value.
   [thet]
 
diff --git a/plone/app/event/dx/behaviors.py b/plone/app/event/dx/behaviors.py
index 9091cfc3..28a6c33d 100644
--- a/plone/app/event/dx/behaviors.py
+++ b/plone/app/event/dx/behaviors.py
@@ -32,6 +32,7 @@
 from z3c.form.browser.textlines import TextLinesFieldWidget
 from zope import schema
 from zope.component import adapter
+from zope.globalrequest import getRequest
 from zope.interface import alsoProvides
 from zope.interface import implementer
 from zope.interface import Invalid
@@ -319,21 +320,6 @@ class IEventContact(model.Schema):
 alsoProvides(IEventContact, IFormFieldProvider)
 
 
-"""
-if not obj.sync_uid:
-    # sync_uid has to be set for icalendar data exchange.
-    uid = IUUID(obj)
-    # We don't want to fail when getRequest() returns None, e.g when
-    # creating an event during test layer setup time.
-    request = getRequest() or {}
-    domain = request.get('HTTP_HOST')
-    obj.sync_uid = '%s%s' % (
-        uid,
-        '@%s' % domain if domain else ''
-    )
-"""
-
-
 # Attribute indexer
 
 # Start indexer
@@ -367,10 +353,10 @@ def location_indexer(obj):
 # icalendar event UID indexer
 @indexer(IDXEvent)
 def sync_uid_indexer(obj):
-    event = IEventBasic(obj)
-    if not event.sync_uid:
+    sync_uid = IEventAccessor(obj).sync_uid
+    if not sync_uid:
         raise AttributeError
-    return event.sync_uid
+    return sync_uid
 
 
 # Body text indexing
@@ -489,7 +475,7 @@ def start(self):
 
     @start.setter
     def start(self, value):
-        return setattr(self, 'start', value)
+        return setattr(self, 'start', pydt(value))
 
     @property
     def end(self):
@@ -506,7 +492,7 @@ def end(self):
 
     @end.setter
     def end(self, value):
-        return setattr(self, 'end', value)
+        return setattr(self, 'end', pydt(value))
 
     @property
     def timezone(self):
@@ -523,7 +509,20 @@ def timezone(self):
             tz_end = tz.zone
         return tz_start if tz_start == tz_end else (tz_start, tz_end)
 
-    # rw properties not in behaviors (yet) # TODO revisit
+    @property
+    def sync_uid(self):
+        # Return externally set sync_uid or Plone's UUID + @domain.
+        sync_uid = getattr(self.context, 'sync_uid', None)
+        if not sync_uid:
+            # Return internal sync_uid
+            request = getRequest() or {}
+            domain = request.get('HTTP_HOST', None)
+            domain = '@' + domain if domain else ''
+            sync_uid = self.uid + domain if self.uid else None
+        return sync_uid
+
+    # rw properties not in behaviors.
+    # TODO: revisit, deprecate.
 
     @property
     def title(self):
diff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py
index 40b11f5f..b4661042 100644
--- a/plone/app/event/ical/exporter.py
+++ b/plone/app/event/ical/exporter.py
@@ -1,11 +1,10 @@
 from Acquisition import aq_inner
-from Products.ZCatalog.interfaces import ICatalogBrain
 from datetime import datetime
 from datetime import timedelta
 from plone.app.contentlisting.interfaces import IContentListingObject
-from plone.app.event.base import RET_MODE_BRAINS
 from plone.app.event.base import default_timezone
 from plone.app.event.base import get_events
+from plone.app.event.base import RET_MODE_BRAINS
 from plone.event.interfaces import IEvent
 from plone.event.interfaces import IEventAccessor
 from plone.event.interfaces import IICalendar
@@ -14,6 +13,7 @@
 from plone.event.utils import is_datetime
 from plone.event.utils import tzdel
 from plone.event.utils import utc
+from Products.ZCatalog.interfaces import ICatalogBrain
 from zope.interface import implementer
 from zope.publisher.browser import BrowserView
 
@@ -219,11 +219,7 @@ def last_modified(self):
 
     @property
     def uid(self):
-        if self.event.sync_uid:
-            # Re-Use existing icalendar event UID
-            return {'value': self.event.sync_uid}
-        # Else, use plone.uuid
-        return {'value': self.event.uid}
+        return {'value': self.event.sync_uid}
 
     @property
     def url(self):
diff --git a/plone/app/event/ical/importer.py b/plone/app/event/ical/importer.py
index 8d92ac78..4fff7f13 100644
--- a/plone/app/event/ical/importer.py
+++ b/plone/app/event/ical/importer.py
@@ -1,9 +1,5 @@
-from Products.CMFCore.utils import getToolByName
-from Products.CMFPlone.utils import safe_unicode
-from Products.Five.browser import BrowserView
-from Products.statusmessages.interfaces import IStatusMessage
-from plone.app.event import base
 from plone.app.event import messageFactory as _
+from plone.app.event import base
 from plone.app.event.base import AnnotationAdapter
 from plone.app.event.interfaces import IICalendarImportEnabled
 from plone.event.interfaces import IEventAccessor
@@ -14,15 +10,21 @@
 from plone.folder.interfaces import IFolder
 from plone.namedfile.field import NamedFile
 from plone.z3cform.layout import FormWrapper
+from Products.CMFCore.utils import getToolByName
+from Products.CMFPlone.utils import safe_unicode
+from Products.Five.browser import BrowserView
+from Products.statusmessages.interfaces import IStatusMessage
 from z3c.form import button
-from z3c.form import form, field
+from z3c.form import field
+from z3c.form import form
 from zope import schema
 from zope.component import adapter
 from zope.container.interfaces import INameChooser
 from zope.event import notify
-from zope.interface import Interface
-from zope.interface import alsoProvides, noLongerProvides
+from zope.interface import alsoProvides
 from zope.interface import implementer
+from zope.interface import Interface
+from zope.interface import noLongerProvides
 from zope.lifecycleevent import ObjectModifiedEvent
 
 import datetime
@@ -64,11 +66,6 @@ def _from_list(ical, prop):
         val = ical[prop] if prop in ical else []
         if not isinstance(val, list):
             val = [val]
-        #ret = ''
-        #for item in val:
-        #    ret = '%s\n' % ret if ret else ret  # insert linebreak
-        #    ret = '%s%s:%s' % (ret, prop, item.to_ical())
-        #return ret
 
         # Zip multiple lines into one, since jquery.recurrenceinput.js does
         # not support multiple lines here
@@ -142,14 +139,11 @@ def _from_list(ical, prop):
 
         ext_modified = utc(_get_prop('LAST-MODIFIED', item))
 
-        # TODO: better use plone.api for content creation, from which some of
-        # the code here is copied
-
         content = None
         new_content_id = None
         existing_event = None
         sync_uid = _get_prop('UID', item)
-        if sync_strategy != base.SYNC_NONE and sync_uid:
+        if sync_uid and sync_strategy is not base.SYNC_NONE:
             existing_event = _get_by_sync_uid(sync_uid)
         if existing_event:
             if sync_strategy == base.SYNC_KEEP_MINE:
@@ -173,8 +167,6 @@ def _from_list(ical, prop):
             # Else: update
             content = exist_event
         else:
-            # TODO: if AT had the same attrs like IDXEventBase, we could set
-            # everything within this invokeFactory call.
             new_content_id = str(random.randint(0, 99999999))
             container.invokeFactory(event_type,
                                     id=new_content_id,
@@ -197,9 +189,9 @@ def _from_list(ical, prop):
         event.attendees = attendees
         event.contact_name = contact
         event.subjects = categories
-        if sync_strategy != base.SYNC_NONE:
-            # Don't import the sync_uid, if no sync strategy is chosen. Let the
-            # sync_uid be autogenerated then.
+        if sync_uid and sync_strategy is not base.SYNC_NONE:
+            # Set the external sync_uid for sync strategies other than
+            # SYNC_NONE.
             event.sync_uid = sync_uid
         notify(ObjectModifiedEvent(content))
 
@@ -271,14 +263,11 @@ class IIcalendarImportSettings(Interface):
     )
 
 
-@adapter(Interface)
+@adapter(IFolder)
 @implementer(IIcalendarImportSettings)
 class IcalendarImportSettings(AnnotationAdapter):
     """Annotation Adapter for IIcalendarImportSettings.
     """
-    #adapts(IFolder) ## ?? TODO: when adapting this in z3c.form, why is a
-                     ## ATFolder not adaptable to this adapter, when it
-                     ## implements IFolder?
     ANNOTATION_KEY = "icalendar_import_settings"
 
 
@@ -286,10 +275,6 @@ class IcalendarImportSettingsForm(form.Form):
     fields = field.Fields(IIcalendarImportSettings)
     ignoreContext = False
 
-    #TODO: needed?
-    def updateWidgets(self):
-        super(IcalendarImportSettingsForm, self).updateWidgets()
-
     def getContent(self):
         data = {}
         settings = IIcalendarImportSettings(self.context)
diff --git a/plone/app/event/tests/test_dx_behaviors.py b/plone/app/event/tests/test_dx_behaviors.py
index c73cedab..770b6dd7 100644
--- a/plone/app/event/tests/test_dx_behaviors.py
+++ b/plone/app/event/tests/test_dx_behaviors.py
@@ -1,26 +1,27 @@
 # -*- coding: utf-8 -*-
+from datetime import datetime
+from datetime import timedelta
 from OFS.SimpleItem import SimpleItem
-from datetime import datetime, timedelta
 from plone.app.event import base
 from plone.app.event.base import get_events
 from plone.app.event.base import localized_now
+from plone.app.event.dx.behaviors import default_end
+from plone.app.event.dx.behaviors import default_start
 from plone.app.event.dx.behaviors import IEventBasic
 from plone.app.event.dx.behaviors import IEventRecurrence
 from plone.app.event.dx.behaviors import StartBeforeEnd
-from plone.app.event.dx.behaviors import default_end
-from plone.app.event.dx.behaviors import default_start
 from plone.app.event.dx.interfaces import IDXEvent
 from plone.app.event.dx.interfaces import IDXEventRecurrence
-from plone.app.event.upgrades.upgrades import upgrade_attribute_storage
 from plone.app.event.testing import PAEventDX_FUNCTIONAL_TESTING
 from plone.app.event.testing import PAEventDX_INTEGRATION_TESTING
 from plone.app.event.testing import set_browserlayer
 from plone.app.event.testing import set_env_timezone
 from plone.app.event.tests.base_setup import patched_now
+from plone.app.event.upgrades.upgrades import upgrade_attribute_storage
+from plone.app.testing import setRoles
 from plone.app.testing import SITE_OWNER_NAME
 from plone.app.testing import SITE_OWNER_PASSWORD
 from plone.app.testing import TEST_USER_ID
-from plone.app.testing import setRoles
 from plone.app.textfield.value import RichTextValue
 from plone.dexterity.utils import createContentInContainer
 from plone.event.interfaces import IEvent
@@ -28,6 +29,7 @@
 from plone.event.interfaces import IOccurrence
 from plone.event.interfaces import IRecurrenceSupport
 from plone.testing.z2 import Browser
+from plone.uuid.interfaces import IUUID
 from zope.annotation.interfaces import IAnnotations
 
 import mock
@@ -250,7 +252,6 @@ def test_event_accessor(self):
         self.assertEqual(acc.end, e1.end)
 
     def test_event_accessor_whole_day__open_end(self):
-
         at = pytz.timezone("Europe/Vienna")
 
         start = at.localize(datetime(2012, 10, 19, 0, 30))
@@ -286,6 +287,34 @@ def test_event_accessor_whole_day__open_end(self):
         self.assertEqual(acc.start, start_start)
         self.assertEqual(acc.end, end_end)
 
+    def test_event_accessor__sync_uid(self):
+        self.request.set('HTTP_HOST', 'nohost')
+
+        e1 = createContentInContainer(
+            self.portal,
+            'plone.app.event.dx.event',
+            title='event1'
+        )
+        acc = IEventAccessor(e1)
+
+        # setting no sync uid will automatically generate one
+        self.assertTrue(acc.sync_uid, IUUID(e1) + '@nohost')
+        # it's not stored on the object though
+        self.assertEqual(e1.sync_uid, None)
+        # but it's indexed
+        result = self.portal.portal_catalog(sync_uid=IUUID(e1) + '@nohost')
+        self.assertEqual(len(result), 1)
+
+        # Setting the sync_uid
+        acc.sync_uid = 'okay'
+        e1.reindexObject()
+        self.assertEqual(acc.sync_uid, 'okay')
+        # Now, it's also stored on the object itself
+        self.assertEqual(e1.sync_uid, 'okay')
+        # and indexed
+        result = self.portal.portal_catalog(sync_uid='okay')
+        self.assertEqual(len(result), 1)
+
 
 class TestDXIntegration(unittest.TestCase):
     layer = PAEventDX_INTEGRATION_TESTING


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-18T01:22:54+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/f474f7d0229ba6eda66a669a46ff33da34e560f5

When setting start and end via the IEventAccessor, convert it to a Python datetime with timezone information.

Files changed:
M CHANGES.rst
M plone/app/event/dx/behaviors.py
M plone/app/event/tests/test_dx_behaviors.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 486189f2..19e0542e 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,27 +10,7 @@ Breaking changes:
 
 New features:
 
-- add full danish translation
-  [tmog]
-
-Bug fixes:
-
-- *add item here*
-
-- Fix portlet get_calendar_url with unicode search_base.
-  [bsuttor]
-
-New features:
-
-- iCal export: Support property parameters.
-  [thet]
-
-- iCal export: Add ``geo`` for (lat, lng) geolocation coordinates.
-  This method is not implemented and can be used by addons to provide that feature.
-  [thet]
-
-- iCal export: Factor-out all event components from ``ICalendarEventComponent.to_ical`` method into separate properties, so that individual properties can be easier overloaded in subclasses.
-- Add ``rel="nofollow"`` to ical export links for robots to not download them.
+- When setting start and end via the IEventAccessor, convert it to a Python datetime with timezone information.
   [thet]
 
 - iCal export:
@@ -39,8 +19,12 @@ New features:
   - Add ``geo`` for (lat, lng) geolocation coordinates. This method is not implemented and can be used by addons to provide that feature.
   - Factor-out all event components from ``ICalendarEventComponent.to_ical`` method into separate properties, so that individual properties can be easier overloaded in subclasses.
   - Check, if event is really an event before ical-exporting. Fixes a problem when a collection mixes event and non-event like result objects.
+  - Add ``rel="nofollow"`` to ical export links for robots to not download them.
   [thet]
 
+- add full danish translation
+  [tmog]
+
 Bug fixes:
 
 - iCalendar import: Fix usage of ``sync_uid``, which wasn't correctly implemented since plone.app.event 2.0.
@@ -49,6 +33,9 @@ Bug fixes:
 - Raise ``AttributeError`` when attempting to index an empty location attribute value.
   [thet]
 
+- Fix portlet get_calendar_url with unicode search_base.
+  [bsuttor]
+
 - fallback search base URL for calendar/event portlets to NavigationRoot [petschki]
 
 
diff --git a/plone/app/event/dx/behaviors.py b/plone/app/event/dx/behaviors.py
index 28a6c33d..aded161d 100644
--- a/plone/app/event/dx/behaviors.py
+++ b/plone/app/event/dx/behaviors.py
@@ -419,13 +419,17 @@ def __getattr__(self, name):
 
     def __setattr__(self, name, value):
         bm = self._behavior_map
-        if name in ['title', 'description', 'last_modified', 'text']:
-            # custom setters for these attributes
+        try:
+            # see, if attribute is available.
+            object.__getattribute__(self, name)
+            # if so, set the value
             object.__setattr__(self, name, value)
-        if name in bm:  # set the attributes on behaviors
-            behavior = bm[name](self.context, None)
-            if behavior:
-                setattr(behavior, name, safe_unicode(value))
+        except AttributeError:
+            # if not, get the attribute from the behavior map, if available
+            if name in bm:
+                behavior = bm[name](self.context, None)
+                if behavior:
+                    setattr(behavior, name, safe_unicode(value))
 
     def __delattr__(self, name):
         bm = self._behavior_map
@@ -475,7 +479,8 @@ def start(self):
 
     @start.setter
     def start(self, value):
-        return setattr(self, 'start', pydt(value))
+        value = pydt(value)
+        self._behavior_map['start'](self.context).start = value
 
     @property
     def end(self):
@@ -492,7 +497,8 @@ def end(self):
 
     @end.setter
     def end(self, value):
-        return setattr(self, 'end', pydt(value))
+        value = pydt(value)
+        self._behavior_map['end'](self.context).end = value
 
     @property
     def timezone(self):
@@ -530,7 +536,7 @@ def title(self):
 
     @title.setter
     def title(self, value):
-        setattr(self.context, 'title', safe_unicode(value))
+        self.context.title = safe_unicode(value)
 
     @property
     def description(self):
@@ -538,7 +544,7 @@ def description(self):
 
     @description.setter
     def description(self, value):
-        setattr(self.context, 'description', safe_unicode(value))
+        self.context.description = safe_unicode(value)
 
     @property
     def last_modified(self):
@@ -548,7 +554,7 @@ def last_modified(self):
     def last_modified(self, value):
         tz = default_timezone(self.context, as_tzinfo=True)
         mod = DT(pydt(value, missing_zone=tz))
-        setattr(self.context, 'modification_date', mod)
+        self.context.modification_date = mod
 
     @property
     def text(self):
diff --git a/plone/app/event/tests/test_dx_behaviors.py b/plone/app/event/tests/test_dx_behaviors.py
index 770b6dd7..f8aca19c 100644
--- a/plone/app/event/tests/test_dx_behaviors.py
+++ b/plone/app/event/tests/test_dx_behaviors.py
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 from datetime import datetime
 from datetime import timedelta
+from DateTime import DateTime
 from OFS.SimpleItem import SimpleItem
 from plone.app.event import base
 from plone.app.event.base import get_events
@@ -24,6 +25,7 @@
 from plone.app.testing import TEST_USER_ID
 from plone.app.textfield.value import RichTextValue
 from plone.dexterity.utils import createContentInContainer
+from plone.event import utils
 from plone.event.interfaces import IEvent
 from plone.event.interfaces import IEventAccessor
 from plone.event.interfaces import IOccurrence
@@ -252,6 +254,9 @@ def test_event_accessor(self):
         self.assertEqual(acc.end, e1.end)
 
     def test_event_accessor_whole_day__open_end(self):
+        """Also ensures, that accessor method is called for getting start/end
+        instead of a custom __getattr__ version.
+        """
         at = pytz.timezone("Europe/Vienna")
 
         start = at.localize(datetime(2012, 10, 19, 0, 30))
@@ -315,6 +320,37 @@ def test_event_accessor__sync_uid(self):
         result = self.portal.portal_catalog(sync_uid='okay')
         self.assertEqual(len(result), 1)
 
+    def test_event_accessor__start_end(self):
+        e1 = createContentInContainer(
+            self.portal,
+            'plone.app.event.dx.event',
+            title='event1'
+        )
+
+        dt = datetime(2161, 1, 1)  # United Federation of Planets
+        DT = DateTime('2161/01/01 00:00:00 UTC')
+
+        acc = IEventAccessor(e1)
+
+        # Setting a timezone-naive datetime should convert it to UTC
+        acc.start = dt
+        self.assertEqual(acc.start, utils.utc(dt))
+        self.assertEqual(e1.start, utils.utc(dt))
+        # Setting a DateTime should convert it to datetime
+        acc.start = DT
+        self.assertEqual(acc.start, utils.utc(dt))
+        self.assertEqual(e1.start, utils.utc(dt))
+
+        # Same goes for acc.end
+        # Setting a timezone-naive datetime should convert it to UTC
+        acc.end = dt
+        self.assertEqual(acc.end, utils.utc(dt))
+        self.assertEqual(e1.end, utils.utc(dt))
+        # Setting a DateTime should convert it to datetime
+        acc.end = DT
+        self.assertEqual(acc.end, utils.utc(dt))
+        self.assertEqual(e1.end, utils.utc(dt))
+
 
 class TestDXIntegration(unittest.TestCase):
     layer = PAEventDX_INTEGRATION_TESTING


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-22T00:05:35+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/ad766231f39c990ced7b2924e8be7125dd294f4a

test fixes

Files changed:
M plone/app/event/browser/event_listing.py
M plone/app/event/testing.py
M plone/app/event/tests/test_icalendar.py

diff --git a/plone/app/event/browser/event_listing.py b/plone/app/event/browser/event_listing.py
index e8435e2d..ee96cbbb 100644
--- a/plone/app/event/browser/event_listing.py
+++ b/plone/app/event/browser/event_listing.py
@@ -188,12 +188,12 @@ def ical(self):
                              batch=False)
         cal = construct_icalendar(self.context, events)
         name = '%s.ics' % self.context.getId()
-        self.request.RESPONSE.setHeader('Content-Type', 'text/calendar')
-        self.request.RESPONSE.setHeader(
+        self.request.response.setHeader('Content-Type', 'text/calendar')
+        self.request.response.setHeader(
             'Content-Disposition',
             'attachment; filename="%s"' % name
         )
-        self.request.RESPONSE.write(cal.to_ical())
+        self.request.response.write(cal.to_ical())
 
     @property
     def ical_url(self):
diff --git a/plone/app/event/testing.py b/plone/app/event/testing.py
index 8c770261..18b11532 100644
--- a/plone/app/event/testing.py
+++ b/plone/app/event/testing.py
@@ -56,7 +56,7 @@ def setHeader(self, header, value):
         def write(self, msg):
             output.append(msg)
 
-    request.RESPONSE = Response()
+    request.response = Response()
     return headers, output, request
 
 
diff --git a/plone/app/event/tests/test_icalendar.py b/plone/app/event/tests/test_icalendar.py
index 437a460c..da7f122b 100644
--- a/plone/app/event/tests/test_icalendar.py
+++ b/plone/app/event/tests/test_icalendar.py
@@ -42,7 +42,7 @@ def test_event_ical(self):
         headers, output, request = make_fake_response(self.request)
         view = getMultiAdapter((self.now_event, request), name='ics_view')
         view()
-        self.assertEqual(len(headers), 2)
+        self.assertEqual(len(headers), 4)
         self.assertEqual(headers['Content-Type'], 'text/calendar')
         icalstr = ''.join(output)
 
@@ -92,7 +92,7 @@ def test_event_occurrence_ical(self):
         )
         view = getMultiAdapter((occ, request), name='ics_view')
         view()
-        self.assertEqual(len(headers), 2)
+        self.assertEqual(len(headers), 4)
         self.assertEqual(headers['Content-Type'], 'text/calendar')
         icalstr = ''.join(output)
         self.assertTrue('Now Event' in icalstr)
@@ -102,7 +102,7 @@ def test_portal_ical(self):
         headers, output, request = make_fake_response(self.request)
         view = getMultiAdapter((self.portal, request), name='ics_view')
         view()
-        self.assertEqual(len(headers), 2)
+        self.assertEqual(len(headers), 4)
         self.assertEqual(headers['Content-Type'], 'text/calendar')
         icalstr = ''.join(output)
 
@@ -229,7 +229,7 @@ def test_collection_ical(self):
             name='ics_view'
         )
         view()
-        self.assertEqual(len(headers), 2)
+        self.assertEqual(len(headers), 4)
         self.assertEqual(headers['Content-Type'], 'text/calendar')
         icalstr = ''.join(output)
         self.assertEqual(icalstr.count('BEGIN:VEVENT'), 4)
@@ -250,7 +250,7 @@ def test_collection_all_ical(self):
             name='ics_view'
         )
         view()
-        self.assertEqual(len(headers), 2)
+        self.assertEqual(len(headers), 4)
         self.assertEqual(headers['Content-Type'], 'text/calendar')
         icalstr = ''.join(output)
         self.assertEqual(icalstr.count('BEGIN:VEVENT'), 4)


Repository: plone.app.event


Branch: refs/heads/master
Date: 2018-01-22T14:02:31+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/6229e82c546281bac9745712b3b71b28271a4f70

Merge pull request #263 from plone/thet-improvements

some improvements while working on it

Files changed:
M CHANGES.rst
M plone/app/event/browser/event_listing.pt
M plone/app/event/browser/event_listing.py
M plone/app/event/browser/event_summary.pt
M plone/app/event/dx/behaviors.py
M plone/app/event/ical/exporter.py
M plone/app/event/ical/importer.py
M plone/app/event/testing.py
M plone/app/event/tests/test_dx_behaviors.py
M plone/app/event/tests/test_icalendar.py

diff --git a/CHANGES.rst b/CHANGES.rst
index c6b6dcc7..19e0542e 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -10,16 +10,34 @@ Breaking changes:
 
 New features:
 
+- When setting start and end via the IEventAccessor, convert it to a Python datetime with timezone information.
+  [thet]
+
+- iCal export:
+  - More response headers.
+  - Support property parameters.
+  - Add ``geo`` for (lat, lng) geolocation coordinates. This method is not implemented and can be used by addons to provide that feature.
+  - Factor-out all event components from ``ICalendarEventComponent.to_ical`` method into separate properties, so that individual properties can be easier overloaded in subclasses.
+  - Check, if event is really an event before ical-exporting. Fixes a problem when a collection mixes event and non-event like result objects.
+  - Add ``rel="nofollow"`` to ical export links for robots to not download them.
+  [thet]
+
 - add full danish translation
   [tmog]
 
 Bug fixes:
 
-- fallback search base URL for calendar/event portlets to NavigationRoot [petschki]
+- iCalendar import: Fix usage of ``sync_uid``, which wasn't correctly implemented since plone.app.event 2.0.
+  [thet]
+
+- Raise ``AttributeError`` when attempting to index an empty location attribute value.
+  [thet]
 
 - Fix portlet get_calendar_url with unicode search_base.
   [bsuttor]
 
+- fallback search base URL for calendar/event portlets to NavigationRoot [petschki]
+
 
 3.0.7 (2017-11-24)
 ------------------
diff --git a/plone/app/event/browser/event_listing.pt b/plone/app/event/browser/event_listing.pt
index f54e74c8..7f32b9e0 100644
--- a/plone/app/event/browser/event_listing.pt
+++ b/plone/app/event/browser/event_listing.pt
@@ -106,7 +106,7 @@
             </li>
 
             <li>
-              <a class="event_ical"
+              <a class="event_ical" rel="nofollow"
                   tal:define="portal_url context/@@plone_portal_state/portal_url;"
                   tal:attributes="href string:${data/url}/ics_view"
                   title="Download this event in iCal format"
diff --git a/plone/app/event/browser/event_listing.py b/plone/app/event/browser/event_listing.py
index e8435e2d..ee96cbbb 100644
--- a/plone/app/event/browser/event_listing.py
+++ b/plone/app/event/browser/event_listing.py
@@ -188,12 +188,12 @@ def ical(self):
                              batch=False)
         cal = construct_icalendar(self.context, events)
         name = '%s.ics' % self.context.getId()
-        self.request.RESPONSE.setHeader('Content-Type', 'text/calendar')
-        self.request.RESPONSE.setHeader(
+        self.request.response.setHeader('Content-Type', 'text/calendar')
+        self.request.response.setHeader(
             'Content-Disposition',
             'attachment; filename="%s"' % name
         )
-        self.request.RESPONSE.write(cal.to_ical())
+        self.request.response.write(cal.to_ical())
 
     @property
     def ical_url(self):
diff --git a/plone/app/event/browser/event_summary.pt b/plone/app/event/browser/event_summary.pt
index 7eb538c2..4fc53f18 100644
--- a/plone/app/event/browser/event_summary.pt
+++ b/plone/app/event/browser/event_summary.pt
@@ -120,7 +120,7 @@
         <strong i18n:translate="heading_add_to_calendar">Add event to calendar</strong>
         <tal:span tal:define="here_url context/@@plone_context_state/object_url;
                         portal_url context/@@plone_portal_state/portal_url;">
-          <a href="#"
+          <a href="#" rel="nofollow"
              tal:attributes="href string:$here_url/ics_view"
              title="Download this event in iCal format"
              i18n:attributes="title title_add_to_ical;">
diff --git a/plone/app/event/dx/behaviors.py b/plone/app/event/dx/behaviors.py
index 7d3bcc5d..aded161d 100644
--- a/plone/app/event/dx/behaviors.py
+++ b/plone/app/event/dx/behaviors.py
@@ -32,6 +32,7 @@
 from z3c.form.browser.textlines import TextLinesFieldWidget
 from zope import schema
 from zope.component import adapter
+from zope.globalrequest import getRequest
 from zope.interface import alsoProvides
 from zope.interface import implementer
 from zope.interface import Invalid
@@ -319,21 +320,6 @@ class IEventContact(model.Schema):
 alsoProvides(IEventContact, IFormFieldProvider)
 
 
-"""
-if not obj.sync_uid:
-    # sync_uid has to be set for icalendar data exchange.
-    uid = IUUID(obj)
-    # We don't want to fail when getRequest() returns None, e.g when
-    # creating an event during test layer setup time.
-    request = getRequest() or {}
-    domain = request.get('HTTP_HOST')
-    obj.sync_uid = '%s%s' % (
-        uid,
-        '@%s' % domain if domain else ''
-    )
-"""
-
-
 # Attribute indexer
 
 # Start indexer
@@ -358,19 +344,19 @@ def end_indexer(obj):
 @indexer(IDXEvent)
 def location_indexer(obj):
     location_adapter = IEventLocation(obj, None)
-    if location_adapter:
-        return location_adapter.location
-
-    raise AttributeError
+    location = getattr(location_adapter, 'location', None)
+    if not location:
+        raise AttributeError
+    return location
 
 
 # icalendar event UID indexer
 @indexer(IDXEvent)
 def sync_uid_indexer(obj):
-    event = IEventBasic(obj)
-    if not event.sync_uid:
+    sync_uid = IEventAccessor(obj).sync_uid
+    if not sync_uid:
         raise AttributeError
-    return event.sync_uid
+    return sync_uid
 
 
 # Body text indexing
@@ -433,13 +419,17 @@ def __getattr__(self, name):
 
     def __setattr__(self, name, value):
         bm = self._behavior_map
-        if name in ['title', 'description', 'last_modified', 'text']:
-            # custom setters for these attributes
+        try:
+            # see, if attribute is available.
+            object.__getattribute__(self, name)
+            # if so, set the value
             object.__setattr__(self, name, value)
-        if name in bm:  # set the attributes on behaviors
-            behavior = bm[name](self.context, None)
-            if behavior:
-                setattr(behavior, name, safe_unicode(value))
+        except AttributeError:
+            # if not, get the attribute from the behavior map, if available
+            if name in bm:
+                behavior = bm[name](self.context, None)
+                if behavior:
+                    setattr(behavior, name, safe_unicode(value))
 
     def __delattr__(self, name):
         bm = self._behavior_map
@@ -489,7 +479,8 @@ def start(self):
 
     @start.setter
     def start(self, value):
-        return setattr(self, 'start', value)
+        value = pydt(value)
+        self._behavior_map['start'](self.context).start = value
 
     @property
     def end(self):
@@ -506,7 +497,8 @@ def end(self):
 
     @end.setter
     def end(self, value):
-        return setattr(self, 'end', value)
+        value = pydt(value)
+        self._behavior_map['end'](self.context).end = value
 
     @property
     def timezone(self):
@@ -523,7 +515,20 @@ def timezone(self):
             tz_end = tz.zone
         return tz_start if tz_start == tz_end else (tz_start, tz_end)
 
-    # rw properties not in behaviors (yet) # TODO revisit
+    @property
+    def sync_uid(self):
+        # Return externally set sync_uid or Plone's UUID + @domain.
+        sync_uid = getattr(self.context, 'sync_uid', None)
+        if not sync_uid:
+            # Return internal sync_uid
+            request = getRequest() or {}
+            domain = request.get('HTTP_HOST', None)
+            domain = '@' + domain if domain else ''
+            sync_uid = self.uid + domain if self.uid else None
+        return sync_uid
+
+    # rw properties not in behaviors.
+    # TODO: revisit, deprecate.
 
     @property
     def title(self):
@@ -531,7 +536,7 @@ def title(self):
 
     @title.setter
     def title(self, value):
-        setattr(self.context, 'title', safe_unicode(value))
+        self.context.title = safe_unicode(value)
 
     @property
     def description(self):
@@ -539,7 +544,7 @@ def description(self):
 
     @description.setter
     def description(self, value):
-        setattr(self.context, 'description', safe_unicode(value))
+        self.context.description = safe_unicode(value)
 
     @property
     def last_modified(self):
@@ -549,7 +554,7 @@ def last_modified(self):
     def last_modified(self, value):
         tz = default_timezone(self.context, as_tzinfo=True)
         mod = DT(pydt(value, missing_zone=tz))
-        setattr(self.context, 'modification_date', mod)
+        self.context.modification_date = mod
 
     @property
     def text(self):
diff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py
index 446101de..b4661042 100644
--- a/plone/app/event/ical/exporter.py
+++ b/plone/app/event/ical/exporter.py
@@ -1,11 +1,11 @@
 from Acquisition import aq_inner
-from Products.ZCatalog.interfaces import ICatalogBrain
 from datetime import datetime
 from datetime import timedelta
 from plone.app.contentlisting.interfaces import IContentListingObject
-from plone.app.event.base import RET_MODE_BRAINS
 from plone.app.event.base import default_timezone
 from plone.app.event.base import get_events
+from plone.app.event.base import RET_MODE_BRAINS
+from plone.event.interfaces import IEvent
 from plone.event.interfaces import IEventAccessor
 from plone.event.interfaces import IICalendar
 from plone.event.interfaces import IICalendarEventComponent
@@ -13,6 +13,7 @@
 from plone.event.utils import is_datetime
 from plone.event.utils import tzdel
 from plone.event.utils import utc
+from Products.ZCatalog.interfaces import ICatalogBrain
 from zope.interface import implementer
 from zope.publisher.browser import BrowserView
 
@@ -49,6 +50,9 @@ def construct_icalendar(context, events):
         if ICatalogBrain.providedBy(event) or\
                 IContentListingObject.providedBy(event):
             event = event.getObject()
+        if not (IEvent.providedBy(event) or IOccurrence.providedBy(event)):
+            # Must be an event.
+            continue
         acc = IEventAccessor(event)
         tz = acc.timezone
         # TODO: the standard wants each recurrence to have a valid timezone
@@ -195,35 +199,61 @@ class ICalendarEventComponent(object):
 
     def __init__(self, context):
         self.context = context
-        self.event = IEventAccessor(context)
-
-    def to_ical(self):
-        ical = icalendar.Event()
-        event = self.event
-
-        # TODO: event.text
-
-        # must be in utc
-        ical.add('dtstamp', utc(datetime.now()))
-        ical.add('created', utc(event.created))
-        ical.add('last-modified', utc(event.last_modified))
-
-        if event.sync_uid:
-            # Re-Use existing icalendar event UID
-            ical.add('uid', event.sync_uid)
-        else:
-            # Else, use plone.uuid
-            ical.add('uid', event.uid)
-
-        ical.add('url', event.url)
-
-        ical.add('summary', event.title)
-
-        if event.description:
-            ical.add('description', event.description)
-
-        if event.whole_day:
-            ical.add('dtstart', event.start.date())
+        self.event = IEventAccessor(self.context)
+        self.ical = icalendar.Event()
+
+    @property
+    def dtstamp(self):
+        # must be in uc
+        return {'value': utc(datetime.now())}
+
+    @property
+    def created(self):
+        # must be in uc
+        return {'value': utc(self.event.created)}
+
+    @property
+    def last_modified(self):
+        # must be in uc
+        return {'value': utc(self.event.last_modified)}
+
+    @property
+    def uid(self):
+        return {'value': self.event.sync_uid}
+
+    @property
+    def url(self):
+        return {'value': self.event.url}
+
+    @property
+    def summary(self):
+        return {'value': self.event.title}
+
+    @property
+    def description(self):
+        return {'value': self.event.description}
+
+    @property
+    def dtstart(self):
+        if self.event.whole_day:
+            # RFC5545, 3.6.1
+            # For cases where a "VEVENT" calendar component
+            # specifies a "DTSTART" property with a DATE value type but no
+            # "DTEND" nor "DURATION" property, the event's duration is taken to
+            # be one day.
+            return {'value': self.event.start.date()}
+
+        # Normal case + Open End case:
+        # RFC5545, 3.6.1
+        # For cases where a "VEVENT" calendar component
+        # specifies a "DTSTART" property with a DATE-TIME value type but no
+        # "DTEND" property, the event ends on the same calendar date and
+        # time of day specified by the "DTSTART" property.
+        return {'value': self.event.start}
+
+    @property
+    def dtend(self):
+        if self.event.whole_day:
             # RFC5545, 3.6.1
             # For cases where a "VEVENT" calendar component
             # specifies a "DTSTART" property with a DATE value type but no
@@ -244,55 +274,76 @@ def to_ical(self):
             # -appointments-in-ics-files
             # http://icalevents.com/1778-all-day-events-adding-a-day-or-not/
             # http://www.innerjoin.org/iCalendar/all-day-events.html
-            ical.add('dtend', event.end.date() + timedelta(days=1))
-        elif event.open_end:
+            return {'value': self.event.end.date() + timedelta(days=1)}
+
+        elif self.event.open_end:
             # RFC5545, 3.6.1
             # For cases where a "VEVENT" calendar component
             # specifies a "DTSTART" property with a DATE-TIME value type but no
             # "DTEND" property, the event ends on the same calendar date and
             # time of day specified by the "DTSTART" property.
-            ical.add('dtstart', event.start)
-        else:
-            ical.add('dtstart', event.start)
-            ical.add('dtend', event.end)
-
-        if event.recurrence and not IOccurrence.providedBy(self.context):
-            for recdef in event.recurrence.split():
-                prop, val = recdef.split(':')
-                if prop == 'RRULE':
-                    ical.add(prop, icalendar.prop.vRecur.from_ical(val))
-                elif prop in ('EXDATE', 'RDATE'):
-                    factory = icalendar.prop.vDDDLists
-
-                    # localize ex/rdate
-                    # TODO: should better already be localized by event object
-                    tzid = event.timezone
-                    if isinstance(tzid, tuple):
-                        tzid = tzid[0]
-                    # get list of datetime values from ical string
-                    try:
-                        dtlist = factory.from_ical(val, timezone=tzid)
-                    except ValueError:
-                        # TODO: caused by a bug in plone.formwidget.recurrence,
-                        # where the recurrencewidget or plone.event fails with
-                        # COUNT=1 and a extra RDATE.
-                        # TODO: REMOVE this workaround, once this failure is
-                        # fixed in recurrence widget.
-                        continue
-                    ical.add(prop, dtlist)
-
-        if event.location:
-            ical.add('location', event.location)
-
+            return None
+
+        return {'value': self.event.end}
+
+    @property
+    def recurrence(self):
+        if not self.event.recurrence or IOccurrence.providedBy(self.context):
+            return None
+
+        ret = []
+        for recdef in self.event.recurrence.split():
+            prop, val = recdef.split(':')
+            if prop == 'RRULE':
+                ret.append({
+                    'property': prop,
+                    'value': icalendar.prop.vRecur.from_ical(val)
+                })
+
+            elif prop in ('EXDATE', 'RDATE'):
+                factory = icalendar.prop.vDDDLists
+
+                # localize ex/rdate
+                # TODO: should better already be localized by event object
+                tzid = self.event.timezone
+                if isinstance(tzid, tuple):
+                    tzid = tzid[0]
+                # get list of datetime values from ical string
+                try:
+                    dtlist = factory.from_ical(val, timezone=tzid)
+                except ValueError:
+                    # TODO: caused by a bug in plone.formwidget.recurrence,
+                    # where the recurrencewidget or plone.event fails with
+                    # COUNT=1 and a extra RDATE.
+                    # TODO: REMOVE this workaround, once this failure is
+                    # fixed in recurrence widget.
+                    continue
+                ret.append({
+                    'property': prop,
+                    'value': dtlist
+                })
+
+        return ret
+
+    @property
+    def location(self):
+        return {'value': self.event.location}
+
+    @property
+    def attendee(self):
         # TODO: revisit and implement attendee export according to RFC
-        if event.attendees:
-            for attendee in event.attendees:
-                att = icalendar.prop.vCalAddress(attendee)
-                att.params['cn'] = icalendar.prop.vText(attendee)
-                att.params['ROLE'] = icalendar.prop.vText('REQ-PARTICIPANT')
-                ical.add('attendee', att)
-
+        ret = []
+        for attendee in self.event.attendees or []:
+            att = icalendar.prop.vCalAddress(attendee)
+            att.params['cn'] = icalendar.prop.vText(attendee)
+            att.params['ROLE'] = icalendar.prop.vText('REQ-PARTICIPANT')
+            ret.append(att)
+        return {'value': ret}
+
+    @property
+    def contact(self):
         cn = []
+        event = self.event
         if event.contact_name:
             cn.append(event.contact_name)
         if event.contact_phone:
@@ -301,14 +352,59 @@ def to_ical(self):
             cn.append(event.contact_email)
         if event.event_url:
             cn.append(event.event_url)
-        if cn:
-            ical.add('contact', u', '.join(cn))
 
-        if event.subjects:
-            for subject in event.subjects:
-                ical.add('categories', subject)
+        return {'value': u', '.join(cn)}
+
+    @property
+    def categories(self):
+        ret = []
+        for cat in self.event.subjects or []:
+            ret.append({'value': cat})
+        return ret or None
+
+    @property
+    def geo(self):
+        """Not implemented.
+        """
+        return
+
+    def ical_add(self, prop, val):
+        if not val:
+            return
+
+        if not isinstance(val, list):
+            val = [val]
+
+        for _val in val:
+            assert(isinstance(_val, dict))
+            value = _val['value']
+            if not value:
+                continue
+            prop = _val.get('property', prop)
+            params = _val.get('parameters', None)
+            self.ical.add(prop, value, params)
+
+    def to_ical(self):
+        # TODO: event.text
 
-        return ical
+        ical_add = self.ical_add
+        ical_add('dtstamp', self.dtstamp)
+        ical_add('created', self.created)
+        ical_add('last-modified', self.last_modified)
+        ical_add('uid', self.uid)
+        ical_add('url', self.url)
+        ical_add('summary', self.summary)
+        ical_add('description', self.description)
+        ical_add('dtstart', self.dtstart)
+        ical_add('dtend', self.dtend)
+        ical_add(None, self.recurrence)  # property key set via val
+        ical_add('location', self.location)
+        ical_add('attendee', self.attendee)
+        ical_add('contact', self.contact)
+        ical_add('categories', self.categories)
+        ical_add('geo', self.geo)
+
+        return self.ical
 
 
 class EventsICal(BrowserView):
@@ -320,10 +416,13 @@ def get_ical_string(self):
         return cal.to_ical()
 
     def __call__(self):
-        name = '%s.ics' % self.context.getId()
-        self.request.RESPONSE.setHeader('Content-Type', 'text/calendar')
-        self.request.RESPONSE.setHeader(
+        ical = self.get_ical_string()
+        name = '{0}.ics'.format(self.context.getId())
+        self.request.response.setHeader('Content-Type', 'text/calendar')
+        self.request.response.setHeader(
             'Content-Disposition',
-            'attachment; filename="%s"' % name
+            'attachment; filename="{0}"'.format(name)
         )
-        self.request.RESPONSE.write(self.get_ical_string())
+        self.request.response.setHeader('Content-Length', len(ical))
+        self.request.response.setHeader('Pragma', 'no-cache')
+        self.request.response.write(ical)
diff --git a/plone/app/event/ical/importer.py b/plone/app/event/ical/importer.py
index 8d92ac78..4fff7f13 100644
--- a/plone/app/event/ical/importer.py
+++ b/plone/app/event/ical/importer.py
@@ -1,9 +1,5 @@
-from Products.CMFCore.utils import getToolByName
-from Products.CMFPlone.utils import safe_unicode
-from Products.Five.browser import BrowserView
-from Products.statusmessages.interfaces import IStatusMessage
-from plone.app.event import base
 from plone.app.event import messageFactory as _
+from plone.app.event import base
 from plone.app.event.base import AnnotationAdapter
 from plone.app.event.interfaces import IICalendarImportEnabled
 from plone.event.interfaces import IEventAccessor
@@ -14,15 +10,21 @@
 from plone.folder.interfaces import IFolder
 from plone.namedfile.field import NamedFile
 from plone.z3cform.layout import FormWrapper
+from Products.CMFCore.utils import getToolByName
+from Products.CMFPlone.utils import safe_unicode
+from Products.Five.browser import BrowserView
+from Products.statusmessages.interfaces import IStatusMessage
 from z3c.form import button
-from z3c.form import form, field
+from z3c.form import field
+from z3c.form import form
 from zope import schema
 from zope.component import adapter
 from zope.container.interfaces import INameChooser
 from zope.event import notify
-from zope.interface import Interface
-from zope.interface import alsoProvides, noLongerProvides
+from zope.interface import alsoProvides
 from zope.interface import implementer
+from zope.interface import Interface
+from zope.interface import noLongerProvides
 from zope.lifecycleevent import ObjectModifiedEvent
 
 import datetime
@@ -64,11 +66,6 @@ def _from_list(ical, prop):
         val = ical[prop] if prop in ical else []
         if not isinstance(val, list):
             val = [val]
-        #ret = ''
-        #for item in val:
-        #    ret = '%s\n' % ret if ret else ret  # insert linebreak
-        #    ret = '%s%s:%s' % (ret, prop, item.to_ical())
-        #return ret
 
         # Zip multiple lines into one, since jquery.recurrenceinput.js does
         # not support multiple lines here
@@ -142,14 +139,11 @@ def _from_list(ical, prop):
 
         ext_modified = utc(_get_prop('LAST-MODIFIED', item))
 
-        # TODO: better use plone.api for content creation, from which some of
-        # the code here is copied
-
         content = None
         new_content_id = None
         existing_event = None
         sync_uid = _get_prop('UID', item)
-        if sync_strategy != base.SYNC_NONE and sync_uid:
+        if sync_uid and sync_strategy is not base.SYNC_NONE:
             existing_event = _get_by_sync_uid(sync_uid)
         if existing_event:
             if sync_strategy == base.SYNC_KEEP_MINE:
@@ -173,8 +167,6 @@ def _from_list(ical, prop):
             # Else: update
             content = exist_event
         else:
-            # TODO: if AT had the same attrs like IDXEventBase, we could set
-            # everything within this invokeFactory call.
             new_content_id = str(random.randint(0, 99999999))
             container.invokeFactory(event_type,
                                     id=new_content_id,
@@ -197,9 +189,9 @@ def _from_list(ical, prop):
         event.attendees = attendees
         event.contact_name = contact
         event.subjects = categories
-        if sync_strategy != base.SYNC_NONE:
-            # Don't import the sync_uid, if no sync strategy is chosen. Let the
-            # sync_uid be autogenerated then.
+        if sync_uid and sync_strategy is not base.SYNC_NONE:
+            # Set the external sync_uid for sync strategies other than
+            # SYNC_NONE.
             event.sync_uid = sync_uid
         notify(ObjectModifiedEvent(content))
 
@@ -271,14 +263,11 @@ class IIcalendarImportSettings(Interface):
     )
 
 
-@adapter(Interface)
+@adapter(IFolder)
 @implementer(IIcalendarImportSettings)
 class IcalendarImportSettings(AnnotationAdapter):
     """Annotation Adapter for IIcalendarImportSettings.
     """
-    #adapts(IFolder) ## ?? TODO: when adapting this in z3c.form, why is a
-                     ## ATFolder not adaptable to this adapter, when it
-                     ## implements IFolder?
     ANNOTATION_KEY = "icalendar_import_settings"
 
 
@@ -286,10 +275,6 @@ class IcalendarImportSettingsForm(form.Form):
     fields = field.Fields(IIcalendarImportSettings)
     ignoreContext = False
 
-    #TODO: needed?
-    def updateWidgets(self):
-        super(IcalendarImportSettingsForm, self).updateWidgets()
-
     def getContent(self):
         data = {}
         settings = IIcalendarImportSettings(self.context)
diff --git a/plone/app/event/testing.py b/plone/app/event/testing.py
index 8c770261..18b11532 100644
--- a/plone/app/event/testing.py
+++ b/plone/app/event/testing.py
@@ -56,7 +56,7 @@ def setHeader(self, header, value):
         def write(self, msg):
             output.append(msg)
 
-    request.RESPONSE = Response()
+    request.response = Response()
     return headers, output, request
 
 
diff --git a/plone/app/event/tests/test_dx_behaviors.py b/plone/app/event/tests/test_dx_behaviors.py
index c73cedab..f8aca19c 100644
--- a/plone/app/event/tests/test_dx_behaviors.py
+++ b/plone/app/event/tests/test_dx_behaviors.py
@@ -1,33 +1,37 @@
 # -*- coding: utf-8 -*-
+from datetime import datetime
+from datetime import timedelta
+from DateTime import DateTime
 from OFS.SimpleItem import SimpleItem
-from datetime import datetime, timedelta
 from plone.app.event import base
 from plone.app.event.base import get_events
 from plone.app.event.base import localized_now
+from plone.app.event.dx.behaviors import default_end
+from plone.app.event.dx.behaviors import default_start
 from plone.app.event.dx.behaviors import IEventBasic
 from plone.app.event.dx.behaviors import IEventRecurrence
 from plone.app.event.dx.behaviors import StartBeforeEnd
-from plone.app.event.dx.behaviors import default_end
-from plone.app.event.dx.behaviors import default_start
 from plone.app.event.dx.interfaces import IDXEvent
 from plone.app.event.dx.interfaces import IDXEventRecurrence
-from plone.app.event.upgrades.upgrades import upgrade_attribute_storage
 from plone.app.event.testing import PAEventDX_FUNCTIONAL_TESTING
 from plone.app.event.testing import PAEventDX_INTEGRATION_TESTING
 from plone.app.event.testing import set_browserlayer
 from plone.app.event.testing import set_env_timezone
 from plone.app.event.tests.base_setup import patched_now
+from plone.app.event.upgrades.upgrades import upgrade_attribute_storage
+from plone.app.testing import setRoles
 from plone.app.testing import SITE_OWNER_NAME
 from plone.app.testing import SITE_OWNER_PASSWORD
 from plone.app.testing import TEST_USER_ID
-from plone.app.testing import setRoles
 from plone.app.textfield.value import RichTextValue
 from plone.dexterity.utils import createContentInContainer
+from plone.event import utils
 from plone.event.interfaces import IEvent
 from plone.event.interfaces import IEventAccessor
 from plone.event.interfaces import IOccurrence
 from plone.event.interfaces import IRecurrenceSupport
 from plone.testing.z2 import Browser
+from plone.uuid.interfaces import IUUID
 from zope.annotation.interfaces import IAnnotations
 
 import mock
@@ -250,7 +254,9 @@ def test_event_accessor(self):
         self.assertEqual(acc.end, e1.end)
 
     def test_event_accessor_whole_day__open_end(self):
-
+        """Also ensures, that accessor method is called for getting start/end
+        instead of a custom __getattr__ version.
+        """
         at = pytz.timezone("Europe/Vienna")
 
         start = at.localize(datetime(2012, 10, 19, 0, 30))
@@ -286,6 +292,65 @@ def test_event_accessor_whole_day__open_end(self):
         self.assertEqual(acc.start, start_start)
         self.assertEqual(acc.end, end_end)
 
+    def test_event_accessor__sync_uid(self):
+        self.request.set('HTTP_HOST', 'nohost')
+
+        e1 = createContentInContainer(
+            self.portal,
+            'plone.app.event.dx.event',
+            title='event1'
+        )
+        acc = IEventAccessor(e1)
+
+        # setting no sync uid will automatically generate one
+        self.assertTrue(acc.sync_uid, IUUID(e1) + '@nohost')
+        # it's not stored on the object though
+        self.assertEqual(e1.sync_uid, None)
+        # but it's indexed
+        result = self.portal.portal_catalog(sync_uid=IUUID(e1) + '@nohost')
+        self.assertEqual(len(result), 1)
+
+        # Setting the sync_uid
+        acc.sync_uid = 'okay'
+        e1.reindexObject()
+        self.assertEqual(acc.sync_uid, 'okay')
+        # Now, it's also stored on the object itself
+        self.assertEqual(e1.sync_uid, 'okay')
+        # and indexed
+        result = self.portal.portal_catalog(sync_uid='okay')
+        self.assertEqual(len(result), 1)
+
+    def test_event_accessor__start_end(self):
+        e1 = createContentInContainer(
+            self.portal,
+            'plone.app.event.dx.event',
+            title='event1'
+        )
+
+        dt = datetime(2161, 1, 1)  # United Federation of Planets
+        DT = DateTime('2161/01/01 00:00:00 UTC')
+
+        acc = IEventAccessor(e1)
+
+        # Setting a timezone-naive datetime should convert it to UTC
+        acc.start = dt
+        self.assertEqual(acc.start, utils.utc(dt))
+        self.assertEqual(e1.start, utils.utc(dt))
+        # Setting a DateTime should convert it to datetime
+        acc.start = DT
+        self.assertEqual(acc.start, utils.utc(dt))
+        self.assertEqual(e1.start, utils.utc(dt))
+
+        # Same goes for acc.end
+        # Setting a timezone-naive datetime should convert it to UTC
+        acc.end = dt
+        self.assertEqual(acc.end, utils.utc(dt))
+        self.assertEqual(e1.end, utils.utc(dt))
+        # Setting a DateTime should convert it to datetime
+        acc.end = DT
+        self.assertEqual(acc.end, utils.utc(dt))
+        self.assertEqual(e1.end, utils.utc(dt))
+
 
 class TestDXIntegration(unittest.TestCase):
     layer = PAEventDX_INTEGRATION_TESTING
diff --git a/plone/app/event/tests/test_icalendar.py b/plone/app/event/tests/test_icalendar.py
index c66d2a9e..da7f122b 100644
--- a/plone/app/event/tests/test_icalendar.py
+++ b/plone/app/event/tests/test_icalendar.py
@@ -42,7 +42,7 @@ def test_event_ical(self):
         headers, output, request = make_fake_response(self.request)
         view = getMultiAdapter((self.now_event, request), name='ics_view')
         view()
-        self.assertEqual(len(headers), 2)
+        self.assertEqual(len(headers), 4)
         self.assertEqual(headers['Content-Type'], 'text/calendar')
         icalstr = ''.join(output)
 
@@ -92,7 +92,7 @@ def test_event_occurrence_ical(self):
         )
         view = getMultiAdapter((occ, request), name='ics_view')
         view()
-        self.assertEqual(len(headers), 2)
+        self.assertEqual(len(headers), 4)
         self.assertEqual(headers['Content-Type'], 'text/calendar')
         icalstr = ''.join(output)
         self.assertTrue('Now Event' in icalstr)
@@ -102,7 +102,7 @@ def test_portal_ical(self):
         headers, output, request = make_fake_response(self.request)
         view = getMultiAdapter((self.portal, request), name='ics_view')
         view()
-        self.assertEqual(len(headers), 2)
+        self.assertEqual(len(headers), 4)
         self.assertEqual(headers['Content-Type'], 'text/calendar')
         icalstr = ''.join(output)
 
@@ -229,7 +229,28 @@ def test_collection_ical(self):
             name='ics_view'
         )
         view()
-        self.assertEqual(len(headers), 2)
+        self.assertEqual(len(headers), 4)
+        self.assertEqual(headers['Content-Type'], 'text/calendar')
+        icalstr = ''.join(output)
+        self.assertEqual(icalstr.count('BEGIN:VEVENT'), 4)
+
+    def test_collection_all_ical(self):
+        """Test basic icalendar export from Collections, which returns not only
+        events.
+        """
+        headers, output, request = make_fake_response(self.request)
+        self.portal.collection.query = [
+            {'i': 'portal_type',
+             'o': 'plone.app.querystring.operation.selection.any',
+             'v': ['Event', 'plone.app.event.dx.event', 'Page']
+             },
+        ]
+        view = getMultiAdapter(
+            (self.portal.collection, request),
+            name='ics_view'
+        )
+        view()
+        self.assertEqual(len(headers), 4)
         self.assertEqual(headers['Content-Type'], 'text/calendar')
         icalstr = ''.join(output)
         self.assertEqual(icalstr.count('BEGIN:VEVENT'), 4)



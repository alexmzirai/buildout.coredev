Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2018-01-25T17:01:08+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.cachepurging/commit/175ef839287e79a84265dd2c74a037ea4cc67d1c

Add Python 2 / 3 compatibility

Files changed:
M CHANGES.rst
M plone/cachepurging/browser.py
M plone/cachepurging/purger.py
M plone/cachepurging/rewrite.py
M plone/cachepurging/tests/test_purger.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index c7c4c53..cca4b29 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -14,7 +14,8 @@ New features:
 
 Bug fixes:
 
-- *add item here*
+- Add Python 2 / 3 compatibility
+  [pbauer]
 
 
 1.0.13 (2016-10-04)
diff --git a/plone/cachepurging/browser.py b/plone/cachepurging/browser.py
index af41219..76a5589 100644
--- a/plone/cachepurging/browser.py
+++ b/plone/cachepurging/browser.py
@@ -5,7 +5,7 @@
 from plone.cachepurging.utils import getURLsToPurge
 from plone.cachepurging.utils import isCachePurgingEnabled
 from plone.registry.interfaces import IRegistry
-from StringIO import StringIO
+from six import StringIO
 from z3c.caching.purge import Purge
 from zope.component import getUtility
 from zope.event import notify
diff --git a/plone/cachepurging/purger.py b/plone/cachepurging/purger.py
index 3e298b4..3f673bc 100644
--- a/plone/cachepurging/purger.py
+++ b/plone/cachepurging/purger.py
@@ -14,45 +14,47 @@
 
 from App.config import getConfiguration
 from plone.cachepurging.interfaces import IPurger
+from six.moves import http_client
+from six.moves import queue
+from six.moves import range
+from six.moves import urllib
 from zope.interface import implementer
 from zope.testing.cleanup import addCleanUp
 
 import atexit
-import httplib
 import logging
-import Queue
+import six
 import socket
 import sys
 import threading
 import time
-import urlparse
 
 
 logger = logging.getLogger('plone.cachepurging')
 
 
-class Connection(httplib.HTTPConnection):
+class Connection(http_client.HTTPConnection):
     """A connection that can handle either HTTP or HTTPS
     """
 
     def __init__(self, host, port=None, strict=None, scheme="http", timeout=5):
         self.scheme = scheme
         if scheme == "http":
-            self.default_port = httplib.HTTP_PORT
+            self.default_port = http_client.HTTP_PORT
         elif scheme == "https":
-            self.default_port = httplib.HTTPS_PORT
+            self.default_port = http_client.HTTPS_PORT
         else:
             raise ValueError("Invalid scheme '%s'" % scheme)
-        httplib.HTTPConnection.__init__(self, host, port, strict,
-                                        timeout=timeout)
+        http_client.HTTPConnection.__init__(self, host, port, strict,
+                                            timeout=timeout)
         self.timeout = timeout
 
     def connect(self):
         if self.scheme == "http":
-            httplib.HTTPConnection.connect(self)
+            http_client.HTTPConnection.connect(self)
         elif self.scheme == "https":
             import ssl  # import here in case python has no ssl support
-            # Clone of httplib.HTTPSConnection.connect
+            # Clone of http_client.HTTPSConnection.connect
             sock = socket.create_connection((self.host, self.port),
                                             timeout=self.timeout)
             key_file = cert_file = None
@@ -76,7 +78,7 @@ def __init__(self, factory=Connection, timeout=30, backlog=200,
         self.http_1_1 = http_1_1
 
     def purgeAsync(self, url, httpVerb='PURGE'):
-        (scheme, host, path, params, query, fragment) = urlparse.urlparse(url)
+        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)  # noqa: E501
         __traceback_info__ = (url, httpVerb, scheme, host,
                               path, params, query, fragment)
 
@@ -84,7 +86,7 @@ def purgeAsync(self, url, httpVerb='PURGE'):
         try:
             q.put((url, httpVerb), block=False)
             logger.debug('Queued %s' % url)
-        except Queue.Full:
+        except queue.Full:
             # Make a loud noise. Ideally the queue size would be
             # user-configurable - but the more likely case is that the purge
             # host is down.
@@ -118,18 +120,18 @@ def purgeSync(self, url, httpVerb='PURGE'):
         return status, xcache, xerror
 
     def stopThreads(self, wait=False):
-        for w in self.workers.itervalues():
+        for w in six.itervalues(self.workers):
             w.stopping = True
         # in case the queue is empty, wake it up so the .stopping flag is seen
         for q in self.queues.values():
             try:
                 q.put(None, block=False)
-            except Queue.Full:
+            except queue.Full:
                 # no problem - self.stopping should be seen.
                 pass
         ok = True
         if wait:
-            for w in self.workers.itervalues():
+            for w in six.itervalues(self.workers):
                 w.join(5)
                 if w.isAlive():
                     logger.warning("Worker thread %s failed to terminate", w)
@@ -142,7 +144,7 @@ def getConnection(self, url):
         trapped.
         """
 
-        (scheme, host, path, params, query, fragment) = urlparse.urlparse(url)
+        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)
         #
         # process.
         conn = self.factory(host, scheme=scheme, timeout=self.timeout)
@@ -155,7 +157,7 @@ def getQueueAndWorker(self, url):
         given URL.
         """
 
-        (scheme, host, path, params, query, fragment) = urlparse.urlparse(url)
+        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)
         key = (host, scheme)
         if key not in self.queues:
             self.queueLock.acquire()
@@ -164,9 +166,9 @@ def getQueueAndWorker(self, url):
                     logger.debug("Creating worker thread for %s://%s",
                                  scheme, host)
                     assert key not in self.workers
-                    self.queues[key] = queue = Queue.Queue(self.backlog)
+                    self.queues[key] = queue_ = queue.Queue(self.backlog)
                     self.workers[key] = worker = Worker(
-                        queue, host, scheme, self)
+                        queue_, host, scheme, self)
                     worker.start()
             finally:
                 self.queueLock.release()
@@ -180,7 +182,7 @@ def _purgeSync(self, conn, url, httpVerb):
         header list in ``self.errorHeaders``.
         """
 
-        (scheme, host, path, params, query, fragment) = urlparse.urlparse(url)
+        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)  # noqa: E501
         __traceback_info__ = (url, httpVerb, scheme, host,
                               path, params, query, fragment)
 
@@ -195,7 +197,7 @@ def _purgeSync(self, conn, url, httpVerb):
             # hosting in squid
             path = url
 
-        purge_path = urlparse.urlunparse(
+        purge_path = urllib.parse.urlunparse(
             ('', '', path, params, query, fragment))
         logger.debug('making %s request to %s for %s.',
                      httpVerb, host, purge_path)
@@ -234,7 +236,7 @@ def stop(self):
 
     def run(self):
         logger.debug("%s starting", self)
-        # Queue should always exist!
+        # queue should always exist!
         q = self.producer.queues[(self.host, self.scheme)]
         connection = None
         atexit.register(self.stop)
@@ -271,14 +273,14 @@ def run(self):
                         # connection.  It is not clear if IIS is evil for
                         # not returning a "connection: close" header in this
                         # case (ie, assuming HTTP 1.0 close semantics), or
-                        # if httplib.py is evil for not detecting this
+                        # if http_client.py is evil for not detecting this
                         # situation and flagging will_close.
                         if not self.producer.http_1_1 or resp.will_close:
                             connection.close()
                             connection = None
                         break  # all done with this item!
 
-                    except (httplib.HTTPException, socket.error), e:
+                    except (http_client.HTTPException, socket.error), e:
                         # All errors 'connection' related errors are treated
                         # the same - simply drop the connection and retry.
                         # the process for establishing the connection handles
@@ -323,7 +325,7 @@ def getConnection(self, url):
                     break
                 logger.debug("Error %s connecting to %s - will "
                              "retry in %d second(s)", e, url, wait_time)
-                for i in xrange(wait_time):
+                for i in range(wait_time):
                     if self.stopping:
                         break
                     time.sleep(1)
diff --git a/plone/cachepurging/rewrite.py b/plone/cachepurging/rewrite.py
index c5e3e8b..0be3121 100644
--- a/plone/cachepurging/rewrite.py
+++ b/plone/cachepurging/rewrite.py
@@ -2,13 +2,12 @@
 from plone.cachepurging.interfaces import ICachePurgingSettings
 from plone.cachepurging.interfaces import IPurgePathRewriter
 from plone.registry.interfaces import IRegistry
+from six.moves import urllib
 from zope.component import adapter
 from zope.component import queryUtility
 from zope.interface import implementer
 from zope.interface import Interface
 
-import urlparse
-
 
 @implementer(IPurgePathRewriter)
 @adapter(Interface)
@@ -75,7 +74,7 @@ def __call__(self, path):
 
         paths = []
         for domain in domains:
-            scheme, host = urlparse.urlparse(domain)[:2]
+            scheme, host = urllib.parse.urlparse(domain)[:2]
             paths.append(
                 '/VirtualHostBase/%(scheme)s/%(host)s%(root)s/'
                 'VirtualHostRoot%(prefix)s%(path)s' % {
diff --git a/plone/cachepurging/tests/test_purger.py b/plone/cachepurging/tests/test_purger.py
index 0e2d719..a71b005 100644
--- a/plone/cachepurging/tests/test_purger.py
+++ b/plone/cachepurging/tests/test_purger.py
@@ -3,12 +3,12 @@
 licensed.
 """
 
-from BaseHTTPServer import BaseHTTPRequestHandler
-from BaseHTTPServer import HTTPServer
 from plone.cachepurging.purger import DefaultPurger
+from six.moves import queue
+from six.moves.BaseHTTPServer import BaseHTTPRequestHandler
+from six.moves.BaseHTTPServer import HTTPServer
 
 import os
-import Queue
 import threading
 import time
 import unittest
@@ -28,8 +28,8 @@ def do_PURGE(self):
         # Get the pre-defined response from the server's queue.
         try:
             nr = self.server.response_queue.get(block=False)
-        except Queue.Empty:
-            print "Unexpected connection from the purge tool"
+        except queue.Empty:
+            print("Unexpected connection from the purge tool")
             print self.command, self.path, self.protocol_version
             for h, v in self.headers.items():
                 print "%s: %s" % (h, v)
@@ -68,7 +68,7 @@ class TestHTTPServer(HTTPServer):
 
     def __init__(self, address, handler):
         HTTPServer.__init__(self, address, handler)
-        self.response_queue = Queue.Queue()
+        self.response_queue = queue.Queue()
 
     def queue_response(self, **kw):
         self.response_queue.put(kw)
diff --git a/setup.py b/setup.py
index 69b3377..c0d8f7b 100644
--- a/setup.py
+++ b/setup.py
@@ -33,6 +33,7 @@
         'setuptools',
         'five.globalrequest',
         'plone.registry',
+        'six',
         'z3c.caching',
         'zope.annotation',
         'zope.component',


Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2018-01-28T11:58:34+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.cachepurging/commit/a9b73c4dc18a49a5aeac967ee19aeb189c050207

Merge pull request #9 from plone/python3

Add Python 2 / 3 compatibility

Files changed:
M CHANGES.rst
M plone/cachepurging/browser.py
M plone/cachepurging/purger.py
M plone/cachepurging/rewrite.py
M plone/cachepurging/tests/test_purger.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index c7c4c53..cca4b29 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -14,7 +14,8 @@ New features:
 
 Bug fixes:
 
-- *add item here*
+- Add Python 2 / 3 compatibility
+  [pbauer]
 
 
 1.0.13 (2016-10-04)
diff --git a/plone/cachepurging/browser.py b/plone/cachepurging/browser.py
index af41219..76a5589 100644
--- a/plone/cachepurging/browser.py
+++ b/plone/cachepurging/browser.py
@@ -5,7 +5,7 @@
 from plone.cachepurging.utils import getURLsToPurge
 from plone.cachepurging.utils import isCachePurgingEnabled
 from plone.registry.interfaces import IRegistry
-from StringIO import StringIO
+from six import StringIO
 from z3c.caching.purge import Purge
 from zope.component import getUtility
 from zope.event import notify
diff --git a/plone/cachepurging/purger.py b/plone/cachepurging/purger.py
index 3e298b4..3f673bc 100644
--- a/plone/cachepurging/purger.py
+++ b/plone/cachepurging/purger.py
@@ -14,45 +14,47 @@
 
 from App.config import getConfiguration
 from plone.cachepurging.interfaces import IPurger
+from six.moves import http_client
+from six.moves import queue
+from six.moves import range
+from six.moves import urllib
 from zope.interface import implementer
 from zope.testing.cleanup import addCleanUp
 
 import atexit
-import httplib
 import logging
-import Queue
+import six
 import socket
 import sys
 import threading
 import time
-import urlparse
 
 
 logger = logging.getLogger('plone.cachepurging')
 
 
-class Connection(httplib.HTTPConnection):
+class Connection(http_client.HTTPConnection):
     """A connection that can handle either HTTP or HTTPS
     """
 
     def __init__(self, host, port=None, strict=None, scheme="http", timeout=5):
         self.scheme = scheme
         if scheme == "http":
-            self.default_port = httplib.HTTP_PORT
+            self.default_port = http_client.HTTP_PORT
         elif scheme == "https":
-            self.default_port = httplib.HTTPS_PORT
+            self.default_port = http_client.HTTPS_PORT
         else:
             raise ValueError("Invalid scheme '%s'" % scheme)
-        httplib.HTTPConnection.__init__(self, host, port, strict,
-                                        timeout=timeout)
+        http_client.HTTPConnection.__init__(self, host, port, strict,
+                                            timeout=timeout)
         self.timeout = timeout
 
     def connect(self):
         if self.scheme == "http":
-            httplib.HTTPConnection.connect(self)
+            http_client.HTTPConnection.connect(self)
         elif self.scheme == "https":
             import ssl  # import here in case python has no ssl support
-            # Clone of httplib.HTTPSConnection.connect
+            # Clone of http_client.HTTPSConnection.connect
             sock = socket.create_connection((self.host, self.port),
                                             timeout=self.timeout)
             key_file = cert_file = None
@@ -76,7 +78,7 @@ def __init__(self, factory=Connection, timeout=30, backlog=200,
         self.http_1_1 = http_1_1
 
     def purgeAsync(self, url, httpVerb='PURGE'):
-        (scheme, host, path, params, query, fragment) = urlparse.urlparse(url)
+        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)  # noqa: E501
         __traceback_info__ = (url, httpVerb, scheme, host,
                               path, params, query, fragment)
 
@@ -84,7 +86,7 @@ def purgeAsync(self, url, httpVerb='PURGE'):
         try:
             q.put((url, httpVerb), block=False)
             logger.debug('Queued %s' % url)
-        except Queue.Full:
+        except queue.Full:
             # Make a loud noise. Ideally the queue size would be
             # user-configurable - but the more likely case is that the purge
             # host is down.
@@ -118,18 +120,18 @@ def purgeSync(self, url, httpVerb='PURGE'):
         return status, xcache, xerror
 
     def stopThreads(self, wait=False):
-        for w in self.workers.itervalues():
+        for w in six.itervalues(self.workers):
             w.stopping = True
         # in case the queue is empty, wake it up so the .stopping flag is seen
         for q in self.queues.values():
             try:
                 q.put(None, block=False)
-            except Queue.Full:
+            except queue.Full:
                 # no problem - self.stopping should be seen.
                 pass
         ok = True
         if wait:
-            for w in self.workers.itervalues():
+            for w in six.itervalues(self.workers):
                 w.join(5)
                 if w.isAlive():
                     logger.warning("Worker thread %s failed to terminate", w)
@@ -142,7 +144,7 @@ def getConnection(self, url):
         trapped.
         """
 
-        (scheme, host, path, params, query, fragment) = urlparse.urlparse(url)
+        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)
         #
         # process.
         conn = self.factory(host, scheme=scheme, timeout=self.timeout)
@@ -155,7 +157,7 @@ def getQueueAndWorker(self, url):
         given URL.
         """
 
-        (scheme, host, path, params, query, fragment) = urlparse.urlparse(url)
+        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)
         key = (host, scheme)
         if key not in self.queues:
             self.queueLock.acquire()
@@ -164,9 +166,9 @@ def getQueueAndWorker(self, url):
                     logger.debug("Creating worker thread for %s://%s",
                                  scheme, host)
                     assert key not in self.workers
-                    self.queues[key] = queue = Queue.Queue(self.backlog)
+                    self.queues[key] = queue_ = queue.Queue(self.backlog)
                     self.workers[key] = worker = Worker(
-                        queue, host, scheme, self)
+                        queue_, host, scheme, self)
                     worker.start()
             finally:
                 self.queueLock.release()
@@ -180,7 +182,7 @@ def _purgeSync(self, conn, url, httpVerb):
         header list in ``self.errorHeaders``.
         """
 
-        (scheme, host, path, params, query, fragment) = urlparse.urlparse(url)
+        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)  # noqa: E501
         __traceback_info__ = (url, httpVerb, scheme, host,
                               path, params, query, fragment)
 
@@ -195,7 +197,7 @@ def _purgeSync(self, conn, url, httpVerb):
             # hosting in squid
             path = url
 
-        purge_path = urlparse.urlunparse(
+        purge_path = urllib.parse.urlunparse(
             ('', '', path, params, query, fragment))
         logger.debug('making %s request to %s for %s.',
                      httpVerb, host, purge_path)
@@ -234,7 +236,7 @@ def stop(self):
 
     def run(self):
         logger.debug("%s starting", self)
-        # Queue should always exist!
+        # queue should always exist!
         q = self.producer.queues[(self.host, self.scheme)]
         connection = None
         atexit.register(self.stop)
@@ -271,14 +273,14 @@ def run(self):
                         # connection.  It is not clear if IIS is evil for
                         # not returning a "connection: close" header in this
                         # case (ie, assuming HTTP 1.0 close semantics), or
-                        # if httplib.py is evil for not detecting this
+                        # if http_client.py is evil for not detecting this
                         # situation and flagging will_close.
                         if not self.producer.http_1_1 or resp.will_close:
                             connection.close()
                             connection = None
                         break  # all done with this item!
 
-                    except (httplib.HTTPException, socket.error), e:
+                    except (http_client.HTTPException, socket.error), e:
                         # All errors 'connection' related errors are treated
                         # the same - simply drop the connection and retry.
                         # the process for establishing the connection handles
@@ -323,7 +325,7 @@ def getConnection(self, url):
                     break
                 logger.debug("Error %s connecting to %s - will "
                              "retry in %d second(s)", e, url, wait_time)
-                for i in xrange(wait_time):
+                for i in range(wait_time):
                     if self.stopping:
                         break
                     time.sleep(1)
diff --git a/plone/cachepurging/rewrite.py b/plone/cachepurging/rewrite.py
index c5e3e8b..0be3121 100644
--- a/plone/cachepurging/rewrite.py
+++ b/plone/cachepurging/rewrite.py
@@ -2,13 +2,12 @@
 from plone.cachepurging.interfaces import ICachePurgingSettings
 from plone.cachepurging.interfaces import IPurgePathRewriter
 from plone.registry.interfaces import IRegistry
+from six.moves import urllib
 from zope.component import adapter
 from zope.component import queryUtility
 from zope.interface import implementer
 from zope.interface import Interface
 
-import urlparse
-
 
 @implementer(IPurgePathRewriter)
 @adapter(Interface)
@@ -75,7 +74,7 @@ def __call__(self, path):
 
         paths = []
         for domain in domains:
-            scheme, host = urlparse.urlparse(domain)[:2]
+            scheme, host = urllib.parse.urlparse(domain)[:2]
             paths.append(
                 '/VirtualHostBase/%(scheme)s/%(host)s%(root)s/'
                 'VirtualHostRoot%(prefix)s%(path)s' % {
diff --git a/plone/cachepurging/tests/test_purger.py b/plone/cachepurging/tests/test_purger.py
index 0e2d719..a71b005 100644
--- a/plone/cachepurging/tests/test_purger.py
+++ b/plone/cachepurging/tests/test_purger.py
@@ -3,12 +3,12 @@
 licensed.
 """
 
-from BaseHTTPServer import BaseHTTPRequestHandler
-from BaseHTTPServer import HTTPServer
 from plone.cachepurging.purger import DefaultPurger
+from six.moves import queue
+from six.moves.BaseHTTPServer import BaseHTTPRequestHandler
+from six.moves.BaseHTTPServer import HTTPServer
 
 import os
-import Queue
 import threading
 import time
 import unittest
@@ -28,8 +28,8 @@ def do_PURGE(self):
         # Get the pre-defined response from the server's queue.
         try:
             nr = self.server.response_queue.get(block=False)
-        except Queue.Empty:
-            print "Unexpected connection from the purge tool"
+        except queue.Empty:
+            print("Unexpected connection from the purge tool")
             print self.command, self.path, self.protocol_version
             for h, v in self.headers.items():
                 print "%s: %s" % (h, v)
@@ -68,7 +68,7 @@ class TestHTTPServer(HTTPServer):
 
     def __init__(self, address, handler):
         HTTPServer.__init__(self, address, handler)
-        self.response_queue = Queue.Queue()
+        self.response_queue = queue.Queue()
 
     def queue_response(self, **kw):
         self.response_queue.put(kw)
diff --git a/setup.py b/setup.py
index 69b3377..c0d8f7b 100644
--- a/setup.py
+++ b/setup.py
@@ -33,6 +33,7 @@
         'setuptools',
         'five.globalrequest',
         'plone.registry',
+        'six',
         'z3c.caching',
         'zope.annotation',
         'zope.component',



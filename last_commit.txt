Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2018-01-31T20:45:06+01:00
Author: Davi Lima (davilima6) <davilima6@gmail.com>
Commit: https://github.com/plone/Products.CMFEditions/commit/5d7d586a62b41d887ce38a2d19179d45e16db643

Prefer newer assert methods

Files changed:
M Products/CMFEditions/tests/test_ATContentTypes.py
M Products/CMFEditions/tests/test_ATReferences.py
M Products/CMFEditions/tests/test_ArchivistTool.py
M Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py
M Products/CMFEditions/tests/test_IntegrationTests.py
M Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
M Products/CMFEditions/tests/test_ZVCStorageTool.py

diff --git a/Products/CMFEditions/tests/test_ATContentTypes.py b/Products/CMFEditions/tests/test_ATContentTypes.py
index edd0fff..3cf32b8 100644
--- a/Products/CMFEditions/tests/test_ATContentTypes.py
+++ b/Products/CMFEditions/tests/test_ATContentTypes.py
@@ -200,13 +200,13 @@ def testBlobsNotResavedUnlessChanged(self):
         # The blobs we use for versioning are different from the
         # original blob though.  Otherwise we wouldn't have a reliable
         # solution
-        self.failIfEqual(original_blob, blob1)
+        self.assertNotEqual(original_blob, blob1)
         # Our third revision has a distinct blob from the current
         # object even though the contents are the same
         vdata = portal_repository.retrieve(content, 2)
         obj = vdata.object
         self.assertEqual(str(obj.getFile()), file2)
-        self.failIfEqual(obj.getFile().getBlob(), content.getFile().getBlob())
+        self.assertNotEqual(obj.getFile().getBlob(), content.getFile().getBlob())
         # Reverting gives us the blob saved in versioning, not the original
         portal_repository.revert(content, 0)
         self.assertEqual(content.getFile().getBlob(), blob1)
diff --git a/Products/CMFEditions/tests/test_ATReferences.py b/Products/CMFEditions/tests/test_ATReferences.py
index 7c266b3..dec1f66 100644
--- a/Products/CMFEditions/tests/test_ATReferences.py
+++ b/Products/CMFEditions/tests/test_ATReferences.py
@@ -37,7 +37,7 @@ def test_referencesDataGetSavedAndRestored(self):
         refs = getattr(doc1, refs_container_name).objectValues()
         doc1.deleteReference(doc2)
         should_be_empty_now = getattr(doc1, refs_container_name).objectValues()
-        self.failIf(should_be_empty_now)
+        self.assertFalse(should_be_empty_now)
         repo.revert(doc1, 1)
         after_retrieve_refs = getattr(doc1, refs_container_name).objectValues()
         self.assertEqual(refs[0].targetUID, after_retrieve_refs[0].targetUID)
@@ -60,7 +60,7 @@ def test_referencesAreSavedAndRestored(self):
         doc1.setTitle('v1')
         repo.save(doc1)
         doc1.deleteReference(doc2)
-        self.failIf(doc1.getReferences(targetObject=doc2))
+        self.assertFalse(doc1.getReferences(targetObject=doc2))
         repo.revert(doc1, 1)
         self.assertEqual(doc1.getReferences(targetObject=doc2), [doc2])
 
@@ -82,7 +82,7 @@ def test_referencesDataGetSavedAndRestored2(self):
         from Products.Archetypes.config import REFERENCE_ANNOTATION
         repo.revert(doc1, 1)
         should_be_empty_now = getattr(doc1, REFERENCE_ANNOTATION).objectValues()
-        self.failIf(should_be_empty_now)
+        self.assertFalse(should_be_empty_now)
 
     def test_referencesAreSavedAndRestored2(self):
         # this case checks restoring a version with no refs, to a workin copy
@@ -100,13 +100,13 @@ def test_referencesAreSavedAndRestored2(self):
         doc1.addReference(doc2)
         self.assertEqual(doc1.getReferences(targetObject=doc2), [doc2])
         repo.revert(doc1, 1)
-        self.failIf(doc1.getReferences(targetObject=doc2))
+        self.assertFalse(doc1.getReferences(targetObject=doc2))
         # The above does not fail because ReferenceCatalog.getReferences calls
         # _resolveBrains after a catalog query to get the reference objects - so
         # the returned list is empty. But the reference_catalog still has the reference
         # indexed:
         rc = self.portal.reference_catalog
-        self.failIf(rc(sourceUID=doc1.UID()))
+        self.assertFalse(rc(sourceUID=doc1.UID()))
 
 
 
@@ -127,7 +127,7 @@ def test_contentReferencesAreSavedAndRestored(self):
 #         ref_doc.setTitle('ref_doc v1')
 #         repo.save(doc1)
 #         doc1.deleteReference(doc2)
-#         self.failIf(doc1.getReferences(targetObject=doc2))
+#         self.assertFalse(doc1.getReferences(targetObject=doc2))
 #         repo.revert(doc1, 1)
 #         self.assertEqual(aq_base(doc1.getReferences(targetObject=doc2)[0]),
 #                          aq_base(doc2))
@@ -150,7 +150,7 @@ def test_referencesAreDeleted(self):
         fol.manage_delObjects('doc2')
         repo.revert(doc1, 1)
         self.assertEqual(doc1.getReferences(), [])
-        self.failIf(doc1.getReferenceImpl())
+        self.assertFalse(doc1.getReferenceImpl())
 
     def test_refcatalogIsUpdatedWithInsideRefsAndATRefsBetweenChildrenObjs(self):
 
@@ -175,8 +175,8 @@ def test_refcatalogIsUpdatedWithInsideRefsAndATRefsBetweenChildrenObjs(self):
         doc1.setTitle('changed')
         doc1.deleteReference(doc2)
         doc2.deleteReference(doc1)
-        self.failIf(doc1.getReferences())
-        self.failIf(doc2.getReferences())
+        self.assertFalse(doc1.getReferences())
+        self.assertFalse(doc2.getReferences())
         repo.revert(fol, 1)
 
         doc1 = self.portal.fol.doc1
diff --git a/Products/CMFEditions/tests/test_ArchivistTool.py b/Products/CMFEditions/tests/test_ArchivistTool.py
index 96084c9..036e8c4 100644
--- a/Products/CMFEditions/tests/test_ArchivistTool.py
+++ b/Products/CMFEditions/tests/test_ArchivistTool.py
@@ -82,7 +82,7 @@ def test01_registerAttachesAHistoryId(self):
         prep = portal_archivist.prepare(doc, app_metadata='save number 1')
         portal_archivist.register(prep)
         history_id = portal_historyidhandler.queryUid(doc)
-        self.failUnless(history_id)
+        self.assertTrue(history_id)
 
     def test02_retrieve(self):
         portal_archivist = self.portal.portal_archivist
@@ -147,8 +147,8 @@ def test04_getHistory(self):
 
         self.assertEqual(len(history), 2)
         # check if timestamp and principal available
-        self.failUnless(history[0].sys_metadata['timestamp'])
-        self.failUnless(history[0].sys_metadata['principal'])
+        self.assertTrue(history[0].sys_metadata['timestamp'])
+        self.assertTrue(history[0].sys_metadata['principal'])
         # check if correct data and metadata retrieved
         self.assertEqual(history[0].data.object.text, 'text v1')
         self.assertEqual(history[0].app_metadata, 'save number 1')
@@ -196,8 +196,8 @@ def test06_getHistoryById(self):
 
         self.assertEqual(len(history), 2)
         # check if timestamp and principal available
-        self.failUnless(history[0].sys_metadata['timestamp'])
-        self.failUnless(history[0].sys_metadata['principal'])
+        self.assertTrue(history[0].sys_metadata['timestamp'])
+        self.assertTrue(history[0].sys_metadata['principal'])
         # check if correct data and metadata retrieved
         self.assertEqual(history[0].data.object.text, 'text v1')
         self.assertEqual(history[0].app_metadata, 'save number 1')
@@ -233,10 +233,10 @@ def test07_prepareObjectWithReferences(self):
         self.assertEqual(len(outside_refs), 1)
         refs = [ref.getAttribute() for ref in inside_refs+outside_refs]
         for ref in refs:
-            self.failUnless(IVersionAwareReference.providedBy(ref))
+            self.assertTrue(IVersionAwareReference.providedBy(ref))
         cloneValues = prep.clone.object.objectValues()
         for sub in cloneValues:
-            self.failUnless(sub in refs)
+            self.assertTrue(sub in refs)
 
         # it is important that the originals returned reference info contain
         # references to the outgoing references
@@ -248,7 +248,7 @@ def test07_prepareObjectWithReferences(self):
         originalValues = prep.original.object.objectValues()
 
         for sub in originalValues:
-            self.failUnless(sub in refs)
+            self.assertTrue(sub in refs)
 
         # the clones and the originals refs must also reference the
         # "same" object
@@ -256,11 +256,11 @@ def test07_prepareObjectWithReferences(self):
                          prep.original.object.objectIds())
 
         self.assertEqual(len(prep.referenced_data), 1)
-        self.failUnless(prep.referenced_data['title'] is fol.title)
+        self.assertTrue(prep.referenced_data['title'] is fol.title)
 
         self.assertEqual(prep.metadata['app_metadata'], 'save number 1')
-        self.failUnless('timestamp' in prep.metadata['sys_metadata'])
-        self.failUnless('principal' in prep.metadata['sys_metadata'])
+        self.assertTrue('timestamp' in prep.metadata['sys_metadata'])
+        self.assertTrue('principal' in prep.metadata['sys_metadata'])
 
         self._setDummyTool(DummyModifier())
 
@@ -296,8 +296,8 @@ def test08_retrieveWithReferences(self):
 
         # check metadata
         self.assertEqual(retr.app_metadata, 'save number 1')
-        self.failUnless('timestamp' in retr.sys_metadata)
-        self.failUnless('principal' in retr.sys_metadata)
+        self.assertTrue('timestamp' in retr.sys_metadata)
+        self.assertTrue('principal' in retr.sys_metadata)
 
         # check the references
         inside_refs = retr.data.inside_refs
@@ -306,7 +306,7 @@ def test08_retrieveWithReferences(self):
         self.assertEqual(len(outside_refs), 1)
         refs = [ref.getAttribute() for ref in inside_refs+outside_refs]
         for ref in refs:
-            self.failUnless(IVersionAwareReference.providedBy(ref))
+            self.assertTrue(IVersionAwareReference.providedBy(ref))
             # check info value (see note above)
             self.assertEquals(ref.info, refs.index(ref))
 
@@ -317,19 +317,19 @@ def test09_isUpToDate(self):
         prep = portal_archivist.prepare(doc, app_metadata='save number 1')
         v1 = portal_archivist.register(prep)
 
-        self.failUnless(portal_archivist.isUpToDate(obj=doc))
-        self.failUnless(portal_archivist.isUpToDate(obj=doc, selector=v1))
+        self.assertTrue(portal_archivist.isUpToDate(obj=doc))
+        self.assertTrue(portal_archivist.isUpToDate(obj=doc, selector=v1))
 
         doc.text = 'text v2'
         notifyModified(doc)
-        self.failIf(portal_archivist.isUpToDate(obj=doc))
+        self.assertFalse(portal_archivist.isUpToDate(obj=doc))
 
         prep = portal_archivist.prepare(doc, app_metadata='save number 2')
         v2 = portal_archivist.save(prep)
 
-        self.failUnless(portal_archivist.isUpToDate(obj=doc))
-        self.failUnless(portal_archivist.isUpToDate(obj=doc, selector=v2))
-        self.failIf(portal_archivist.isUpToDate(obj=doc, selector=v1))
+        self.assertTrue(portal_archivist.isUpToDate(obj=doc))
+        self.assertTrue(portal_archivist.isUpToDate(obj=doc, selector=v2))
+        self.assertFalse(portal_archivist.isUpToDate(obj=doc, selector=v1))
 
     def test09_getHistoryMetadata(self):
         portal_archivist = self.portal.portal_archivist
@@ -347,8 +347,8 @@ def test09_getHistoryMetadata(self):
 
         self.assertEqual(len(history), 2)
         # check if timestamp and principal available
-        self.failUnless(history.retrieve(1)['metadata']['sys_metadata']['timestamp'])
-        self.failUnless(history.retrieve(0)['metadata']['sys_metadata']['principal'])
+        self.assertTrue(history.retrieve(1)['metadata']['sys_metadata']['timestamp'])
+        self.assertTrue(history.retrieve(0)['metadata']['sys_metadata']['principal'])
         # check if correct data and metadata retrieved
         self.assertEqual(history.retrieve(0)['metadata']['app_metadata'], 'save number 1')
         self.assertEqual(history.retrieve(1)['metadata']['app_metadata'], 'save number 2')
@@ -370,8 +370,8 @@ def test09_getHistoryMetadata_byId(self):
 
         self.assertEqual(len(history), 2)
         # check if timestamp and principal available
-        self.failUnless(history.retrieve(1)['metadata']['sys_metadata']['timestamp'])
-        self.failUnless(history.retrieve(0)['metadata']['sys_metadata']['principal'])
+        self.assertTrue(history.retrieve(1)['metadata']['sys_metadata']['timestamp'])
+        self.assertTrue(history.retrieve(0)['metadata']['sys_metadata']['principal'])
         # check if correct data and metadata retrieved
         self.assertEqual(history.retrieve(0)['metadata']['app_metadata'], 'save number 1')
         self.assertEqual(history.retrieve(1)['metadata']['app_metadata'], 'save number 2')
diff --git a/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py b/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py
index c05f0c1..32ffdde 100644
--- a/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py
+++ b/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py
@@ -161,7 +161,7 @@ def test04_isUptoDate(self):
         self.assertEqual(portal_repository.isUpToDate(doc), True)
         doc.text = 'text v2'
         notifyModified(doc)
-        self.failIf(portal_repository.isUpToDate(doc))
+        self.assertFalse(portal_repository.isUpToDate(doc))
 
     def test05_getHistory(self):
         portal_repository = self.portal.portal_repository
@@ -229,7 +229,7 @@ def test07_restoreDeletedObject(self):
 
         # delete the object we want to retrieve later
         self.portal.manage_delObjects(ids=['doc'])
-        self.failIf('doc' in self.portal.objectIds())
+        self.assertFalse('doc' in self.portal.objectIds())
         self.assertRaises(
             AttributeError,
             portal_repository.restore,
@@ -255,7 +255,7 @@ def test07_restoreDeletedObjectWithNewId(self):
 
         # delete the object we want to retrieve later
         self.portal.manage_delObjects(ids=['doc'])
-        self.failIf('doc' in self.portal.objectIds())
+        self.assertFalse('doc' in self.portal.objectIds())
         self.assertRaises(
             AttributeError,
             portal_repository.restore,
@@ -455,7 +455,7 @@ def test01_remove_policy_from_type(self):
                                                         'at_edit_autoversion'))
         portal_repository.removePolicyFromContentType('Document',
                                                         'at_edit_autoversion')
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                         'at_edit_autoversion'))
 
     def test02_set_policy_on_type(self):
@@ -465,7 +465,7 @@ def test02_set_policy_on_type(self):
                                                         'at_edit_autoversion'))
         portal_repository.removePolicyFromContentType('Document',
                                                         'at_edit_autoversion')
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                         'at_edit_autoversion'))
         portal_repository.addPolicyForContentType('Document',
                                                         'at_edit_autoversion')
@@ -495,9 +495,9 @@ def test03_set_policy_types_map(self):
                                                     'at_edit_autoversion',
                                                     'version_on_publish']})
         portal_repository.manage_setTypePolicies({'Document': []})
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                        'at_edit_autoversion'))
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                        'version_on_publish'))
 
 
@@ -530,7 +530,7 @@ def test05_remove_policy(self):
                                                         'version_on_publish')
         portal_repository.removePolicy('version_on_publish')
         self.assertEqual(len(portal_repository.listPolicies()), self.np)
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                         'version_on_publish'))
 
     def test07_set_policy_defs(self):
@@ -594,7 +594,7 @@ def test09_policy_hooks(self):
         self.assertEqual(out, ['added','enabled Document'])
         portal_repository.removePolicyFromContentType('Document',
                                                    'my_bogus_policy', out=out)
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                         'my_bogus_policy'))
         self.assertEqual(out, ['added','enabled Document',
                                                     'disabled Document'])
@@ -653,9 +653,9 @@ def test13_at_auto_version_hooks(self):
                                                      'success', None, None))
         # Remove policy and check if hook is removed
         portal_repository.removePolicy('at_edit_autoversion')
-        self.failIf(self.isFCActionInPlace('validate_integrity',
+        self.assertFalse(self.isFCActionInPlace('validate_integrity',
                                                  'success', None, None))
-        self.failIf(self.isFCActionInPlace('atct_edit',
+        self.assertFalse(self.isFCActionInPlace('atct_edit',
                                                      'success', None, None))
         # Add policy and check if hook is added
         portal_repository.addPolicy('at_edit_autoversion', 'Auto policy',
@@ -673,4 +673,4 @@ def test14_has_policy(self):
                                                         'at_edit_autoversion')
         portal_repository.removePolicyFromContentType('Document',
                                                         'version_on_revert')
-        self.failIf(portal_repository.hasPolicy(self.portal.doc))
+        self.assertFalse(portal_repository.hasPolicy(self.portal.doc))
diff --git a/Products/CMFEditions/tests/test_IntegrationTests.py b/Products/CMFEditions/tests/test_IntegrationTests.py
index 80eee18..e5dd3fb 100644
--- a/Products/CMFEditions/tests/test_IntegrationTests.py
+++ b/Products/CMFEditions/tests/test_IntegrationTests.py
@@ -190,10 +190,10 @@ def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):
         copy = self.portal.copy_of_doc
 
         # the copy shall not have a history yet: that's correct
-        self.failIf(portal_repo.getHistory(copy))
+        self.assertFalse(portal_repo.getHistory(copy))
 
         # just to be sure the history is definitivels different
-        self.failIfEqual(
+        self.assertNotEqual(
             portal_historyidhandler.queryUid(doc),
             portal_historyidhandler.queryUid(copy))  # may be None
 
@@ -333,7 +333,7 @@ def test11_versionAFolderishObjectThatTreatsChildrensAsInsideRefs(self):
         fol = self.portal.fol
         doc1 = fol.doc1
         self.failUnless('doc2' in fol.objectIds())
-        self.failIf('doc3' in fol.objectIds())
+        self.assertFalse('doc3' in fol.objectIds())
         doc2 = fol.doc2
         self.assertEqual(fol.Title(), "v2 of fol")
         self.assertEqual(doc1.Title(), "v2 of doc1")
@@ -678,7 +678,7 @@ def test17_moveInsideRefThenRevertChangesUid(self):
         retrieved_data = portal_repo.retrieve(fol, 0)
         ret_folder = retrieved_data.object
         ret_doc = ret_folder.doc1
-        self.failIf(portal_historyidhandler.queryUid(ret_doc) == orig_uid,
+        self.assertFalse(portal_historyidhandler.queryUid(ret_doc) == orig_uid,
                     "UIDs should not be equal, current value: %s" % orig_uid)
 
         # revert to original state, ensure that subobject changes are
@@ -688,7 +688,7 @@ def test17_moveInsideRefThenRevertChangesUid(self):
         reverted_doc = fol.doc1
 
         # check if reversion worked correctly
-        self.failIf(portal_historyidhandler.queryUid(reverted_doc) == orig_uid,
+        self.assertFalse(portal_historyidhandler.queryUid(reverted_doc) == orig_uid,
                     "UIDs should not be equal, current value: %s" % orig_uid)
 
     def test18_retrieveObjectWhichHasBeenReplaced(self):
@@ -944,7 +944,7 @@ def test21_RestoreMovedObject(self):
         self.assertEqual(len(catalog(Title='v2 of doc1')), 1)
         # The reverted document should have a new uid, because an object with
         # the original uid exists
-        self.failIf(portal_hidhandler.queryUid(res_doc) == history_id)
+        self.assertFalse(portal_hidhandler.queryUid(res_doc) == history_id)
 
     def test22_ParentPointerNotVersionedOrRestored(self):
         portal_repo = self.portal.portal_repository
@@ -1090,7 +1090,7 @@ def test25_versioningRestoresInsideRefsFolderOrder(self):
         # Test that a retrieve uses the order from the repo copy
         repo_fol1 = portal_repo.retrieve(fol, 0).object
         self.failUnlessEqual(fol.objectIds()[0], 'doc2')
-        self.failIfEqual(fol.objectIds(), orig_order)
+        self.assertNotEqual(fol.objectIds(), orig_order)
         self.failUnlessEqual(repo_fol1.objectIds()[0], 'doc1')
 
         # Test that a revert restores the order and objects from the
@@ -1109,7 +1109,7 @@ def test25_versioningRestoresInsideRefsFolderOrder(self):
         doc3 = fol['doc3']
         doc4 = fol['doc4']
 
-        self.failIfEqual(fol.objectIds(), orig_order)
+        self.assertNotEqual(fol.objectIds(), orig_order)
 
         repo_fol1 = portal_repo.retrieve(fol, 0).object
 
@@ -1117,16 +1117,16 @@ def test25_versioningRestoresInsideRefsFolderOrder(self):
         # but does not affect the working copy
         repo_fol1 = portal_repo.retrieve(fol, 0).object
         self.failUnlessEqual(repo_fol1.objectIds(), orig_order)
-        self.failIfEqual(getattr(repo_fol1, 'doc2', None), None)
+        self.assertNotEqual(getattr(repo_fol1, 'doc2', None), None)
         self.failUnlessEqual(getattr(repo_fol1, 'doc5', None), None)
 
-        self.failIfEqual(fol.objectIds(), orig_order)
+        self.assertNotEqual(fol.objectIds(), orig_order)
         self.failUnlessEqual(fol.objectIds()[0], 'doc4')
         self.failUnlessEqual(fol.objectIds()[1], 'doc3')
         self.failUnlessEqual(fol['doc3'], doc3)
         self.failUnlessEqual(fol['doc4'], doc4)
         self.failUnlessEqual(getattr(fol, 'doc2', None), None)
-        self.failIfEqual(getattr(fol, 'doc5', None), None)
+        self.assertNotEqual(getattr(fol, 'doc5', None), None)
 
         # Test that a revert restores the missing child from the repo
         # copy, removed the newly created child and restored the order
diff --git a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
index b0da822..7900345 100644
--- a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
+++ b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
@@ -60,7 +60,7 @@ def test01_beforeSaveHookInfinite(self):
 
         storage.save(history_id=1, obj=DummyData(0))
         res = purgepolicy.beforeSaveHook(history_id=1, obj=2, metadata={})
-        self.failUnless(res)
+        self.assertTrue(res)
         self.assertEqual(len(storage.getHistory(history_id=1)), 1)
 
     def test02_beforeSaveHookKeepsMaximumTwoVersions(self):
@@ -71,20 +71,20 @@ def test02_beforeSaveHookKeepsMaximumTwoVersions(self):
         # call hook explicitely before save (dummy tool doesn't call it,
         # we wan't to do it explicitely)
         res = purgepolicy.beforeSaveHook(history_id=1, obj=2, metadata={})
-        self.failUnless(res)
+        self.assertTrue(res)
         storage.save(history_id=1, obj=DummyData(0))
         self.assertEqual(len(storage.getHistory(history_id=1)), 1)
 
         # call hook explicitely before save (dummy tool doesn't call it,
         # we wan't to do it explicitely)
         res = purgepolicy.beforeSaveHook(history_id=1, obj=2, metadata={})
-        self.failUnless(res)
+        self.assertTrue(res)
         storage.save(history_id=1, obj=DummyData(1))
         self.assertEqual(len(storage.getHistory(history_id=1)), 2)
 
         # check the first saved version was purged
         res = purgepolicy.beforeSaveHook(history_id=1, obj=2, metadata={})
-        self.failUnless(res)
+        self.assertTrue(res)
         storage.save(history_id=1, obj=DummyData(2))
         history = storage.getHistory(history_id=1)
         self.assertEqual(len(history), 2)
diff --git a/Products/CMFEditions/tests/test_ZVCStorageTool.py b/Products/CMFEditions/tests/test_ZVCStorageTool.py
index 70812ba..769ad60 100644
--- a/Products/CMFEditions/tests/test_ZVCStorageTool.py
+++ b/Products/CMFEditions/tests/test_ZVCStorageTool.py
@@ -279,19 +279,19 @@ def test09_retrievePurgedVersionsNoPolicyInstalled(self):
         # ``retrieve`` returns the removed info because there is no purge
         # policy installed
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2)
-        self.failIf(retrieved_obj.isValid())
+        self.assertFalse(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.reason, "purged")
         self.assertEqual(self.getComment(retrieved_obj), "purged v3")
 
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,
                                                 substitute=False)
-        self.failIf(retrieved_obj.isValid())
+        self.assertFalse(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.reason, "purged")
         self.assertEqual(self.getComment(retrieved_obj), "purged v3")
 
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,
                                                 countPurged=False)
-        self.failUnless(retrieved_obj.isValid())
+        self.assertTrue(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.object.text, 'v4 of text')
         self.assertEqual(self.getComment(retrieved_obj), 'saved v4')
 
@@ -318,30 +318,30 @@ def test10_retrievePurgedVersionsWithPolicyInstalled(self):
 
         # ``retrieve`` returns the next older object
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=1)
-        self.failUnless(retrieved_obj.isValid())
+        self.assertTrue(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.object.text, 'v1 of text')
         self.assertEqual(self.getComment(retrieved_obj), 'saved v1')
 
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2)
-        self.failUnless(retrieved_obj.isValid())
+        self.assertTrue(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.object.text, 'v1 of text')
         self.assertEqual(self.getComment(retrieved_obj), 'saved v1')
 
         # ``retrieve`` returns existing object
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=3)
-        self.failUnless(retrieved_obj.isValid())
+        self.assertTrue(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.object.text, 'v4 of text')
         self.assertEqual(self.getComment(retrieved_obj), 'saved v4')
 
         # check with substitute=False: should return the removed info
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=1,
                                                 substitute=False)
-        self.failIf(retrieved_obj.isValid())
+        self.assertFalse(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.reason, "purged")
         self.assertEqual(self.getComment(retrieved_obj), "purged v2")
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,
                                                 substitute=False)
-        self.failIf(retrieved_obj.isValid())
+        self.assertFalse(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.reason, "purged")
         self.assertEqual(self.getComment(retrieved_obj), "purged v3")
 
@@ -571,7 +571,7 @@ def test15_storageStatistics(self):
                 self.assertEqual(actual[key], value)
             # The actual size is not important and we want robust tests,
             # s. https://github.com/plone/Products.CMFEditions/issues/31
-            self.failUnless(actual['size'] > 0)
+            self.assertTrue(actual['size'] > 0)
 
     def test16_delete_history_on_content_deletion(self):
         """ If a content item gets deleted, delete it's history


Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2018-01-31T23:18:19+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/7b14eb9c7958ba34fd901e1c5718cfe342e6c507

Merge pull request #48 from plone/updateToAsserts

Prefer newer assert methods

Files changed:
M Products/CMFEditions/tests/test_ATContentTypes.py
M Products/CMFEditions/tests/test_ATReferences.py
M Products/CMFEditions/tests/test_ArchivistTool.py
M Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py
M Products/CMFEditions/tests/test_IntegrationTests.py
M Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
M Products/CMFEditions/tests/test_ZVCStorageTool.py

diff --git a/Products/CMFEditions/tests/test_ATContentTypes.py b/Products/CMFEditions/tests/test_ATContentTypes.py
index edd0fff..3cf32b8 100644
--- a/Products/CMFEditions/tests/test_ATContentTypes.py
+++ b/Products/CMFEditions/tests/test_ATContentTypes.py
@@ -200,13 +200,13 @@ def testBlobsNotResavedUnlessChanged(self):
         # The blobs we use for versioning are different from the
         # original blob though.  Otherwise we wouldn't have a reliable
         # solution
-        self.failIfEqual(original_blob, blob1)
+        self.assertNotEqual(original_blob, blob1)
         # Our third revision has a distinct blob from the current
         # object even though the contents are the same
         vdata = portal_repository.retrieve(content, 2)
         obj = vdata.object
         self.assertEqual(str(obj.getFile()), file2)
-        self.failIfEqual(obj.getFile().getBlob(), content.getFile().getBlob())
+        self.assertNotEqual(obj.getFile().getBlob(), content.getFile().getBlob())
         # Reverting gives us the blob saved in versioning, not the original
         portal_repository.revert(content, 0)
         self.assertEqual(content.getFile().getBlob(), blob1)
diff --git a/Products/CMFEditions/tests/test_ATReferences.py b/Products/CMFEditions/tests/test_ATReferences.py
index 7c266b3..dec1f66 100644
--- a/Products/CMFEditions/tests/test_ATReferences.py
+++ b/Products/CMFEditions/tests/test_ATReferences.py
@@ -37,7 +37,7 @@ def test_referencesDataGetSavedAndRestored(self):
         refs = getattr(doc1, refs_container_name).objectValues()
         doc1.deleteReference(doc2)
         should_be_empty_now = getattr(doc1, refs_container_name).objectValues()
-        self.failIf(should_be_empty_now)
+        self.assertFalse(should_be_empty_now)
         repo.revert(doc1, 1)
         after_retrieve_refs = getattr(doc1, refs_container_name).objectValues()
         self.assertEqual(refs[0].targetUID, after_retrieve_refs[0].targetUID)
@@ -60,7 +60,7 @@ def test_referencesAreSavedAndRestored(self):
         doc1.setTitle('v1')
         repo.save(doc1)
         doc1.deleteReference(doc2)
-        self.failIf(doc1.getReferences(targetObject=doc2))
+        self.assertFalse(doc1.getReferences(targetObject=doc2))
         repo.revert(doc1, 1)
         self.assertEqual(doc1.getReferences(targetObject=doc2), [doc2])
 
@@ -82,7 +82,7 @@ def test_referencesDataGetSavedAndRestored2(self):
         from Products.Archetypes.config import REFERENCE_ANNOTATION
         repo.revert(doc1, 1)
         should_be_empty_now = getattr(doc1, REFERENCE_ANNOTATION).objectValues()
-        self.failIf(should_be_empty_now)
+        self.assertFalse(should_be_empty_now)
 
     def test_referencesAreSavedAndRestored2(self):
         # this case checks restoring a version with no refs, to a workin copy
@@ -100,13 +100,13 @@ def test_referencesAreSavedAndRestored2(self):
         doc1.addReference(doc2)
         self.assertEqual(doc1.getReferences(targetObject=doc2), [doc2])
         repo.revert(doc1, 1)
-        self.failIf(doc1.getReferences(targetObject=doc2))
+        self.assertFalse(doc1.getReferences(targetObject=doc2))
         # The above does not fail because ReferenceCatalog.getReferences calls
         # _resolveBrains after a catalog query to get the reference objects - so
         # the returned list is empty. But the reference_catalog still has the reference
         # indexed:
         rc = self.portal.reference_catalog
-        self.failIf(rc(sourceUID=doc1.UID()))
+        self.assertFalse(rc(sourceUID=doc1.UID()))
 
 
 
@@ -127,7 +127,7 @@ def test_contentReferencesAreSavedAndRestored(self):
 #         ref_doc.setTitle('ref_doc v1')
 #         repo.save(doc1)
 #         doc1.deleteReference(doc2)
-#         self.failIf(doc1.getReferences(targetObject=doc2))
+#         self.assertFalse(doc1.getReferences(targetObject=doc2))
 #         repo.revert(doc1, 1)
 #         self.assertEqual(aq_base(doc1.getReferences(targetObject=doc2)[0]),
 #                          aq_base(doc2))
@@ -150,7 +150,7 @@ def test_referencesAreDeleted(self):
         fol.manage_delObjects('doc2')
         repo.revert(doc1, 1)
         self.assertEqual(doc1.getReferences(), [])
-        self.failIf(doc1.getReferenceImpl())
+        self.assertFalse(doc1.getReferenceImpl())
 
     def test_refcatalogIsUpdatedWithInsideRefsAndATRefsBetweenChildrenObjs(self):
 
@@ -175,8 +175,8 @@ def test_refcatalogIsUpdatedWithInsideRefsAndATRefsBetweenChildrenObjs(self):
         doc1.setTitle('changed')
         doc1.deleteReference(doc2)
         doc2.deleteReference(doc1)
-        self.failIf(doc1.getReferences())
-        self.failIf(doc2.getReferences())
+        self.assertFalse(doc1.getReferences())
+        self.assertFalse(doc2.getReferences())
         repo.revert(fol, 1)
 
         doc1 = self.portal.fol.doc1
diff --git a/Products/CMFEditions/tests/test_ArchivistTool.py b/Products/CMFEditions/tests/test_ArchivistTool.py
index 96084c9..036e8c4 100644
--- a/Products/CMFEditions/tests/test_ArchivistTool.py
+++ b/Products/CMFEditions/tests/test_ArchivistTool.py
@@ -82,7 +82,7 @@ def test01_registerAttachesAHistoryId(self):
         prep = portal_archivist.prepare(doc, app_metadata='save number 1')
         portal_archivist.register(prep)
         history_id = portal_historyidhandler.queryUid(doc)
-        self.failUnless(history_id)
+        self.assertTrue(history_id)
 
     def test02_retrieve(self):
         portal_archivist = self.portal.portal_archivist
@@ -147,8 +147,8 @@ def test04_getHistory(self):
 
         self.assertEqual(len(history), 2)
         # check if timestamp and principal available
-        self.failUnless(history[0].sys_metadata['timestamp'])
-        self.failUnless(history[0].sys_metadata['principal'])
+        self.assertTrue(history[0].sys_metadata['timestamp'])
+        self.assertTrue(history[0].sys_metadata['principal'])
         # check if correct data and metadata retrieved
         self.assertEqual(history[0].data.object.text, 'text v1')
         self.assertEqual(history[0].app_metadata, 'save number 1')
@@ -196,8 +196,8 @@ def test06_getHistoryById(self):
 
         self.assertEqual(len(history), 2)
         # check if timestamp and principal available
-        self.failUnless(history[0].sys_metadata['timestamp'])
-        self.failUnless(history[0].sys_metadata['principal'])
+        self.assertTrue(history[0].sys_metadata['timestamp'])
+        self.assertTrue(history[0].sys_metadata['principal'])
         # check if correct data and metadata retrieved
         self.assertEqual(history[0].data.object.text, 'text v1')
         self.assertEqual(history[0].app_metadata, 'save number 1')
@@ -233,10 +233,10 @@ def test07_prepareObjectWithReferences(self):
         self.assertEqual(len(outside_refs), 1)
         refs = [ref.getAttribute() for ref in inside_refs+outside_refs]
         for ref in refs:
-            self.failUnless(IVersionAwareReference.providedBy(ref))
+            self.assertTrue(IVersionAwareReference.providedBy(ref))
         cloneValues = prep.clone.object.objectValues()
         for sub in cloneValues:
-            self.failUnless(sub in refs)
+            self.assertTrue(sub in refs)
 
         # it is important that the originals returned reference info contain
         # references to the outgoing references
@@ -248,7 +248,7 @@ def test07_prepareObjectWithReferences(self):
         originalValues = prep.original.object.objectValues()
 
         for sub in originalValues:
-            self.failUnless(sub in refs)
+            self.assertTrue(sub in refs)
 
         # the clones and the originals refs must also reference the
         # "same" object
@@ -256,11 +256,11 @@ def test07_prepareObjectWithReferences(self):
                          prep.original.object.objectIds())
 
         self.assertEqual(len(prep.referenced_data), 1)
-        self.failUnless(prep.referenced_data['title'] is fol.title)
+        self.assertTrue(prep.referenced_data['title'] is fol.title)
 
         self.assertEqual(prep.metadata['app_metadata'], 'save number 1')
-        self.failUnless('timestamp' in prep.metadata['sys_metadata'])
-        self.failUnless('principal' in prep.metadata['sys_metadata'])
+        self.assertTrue('timestamp' in prep.metadata['sys_metadata'])
+        self.assertTrue('principal' in prep.metadata['sys_metadata'])
 
         self._setDummyTool(DummyModifier())
 
@@ -296,8 +296,8 @@ def test08_retrieveWithReferences(self):
 
         # check metadata
         self.assertEqual(retr.app_metadata, 'save number 1')
-        self.failUnless('timestamp' in retr.sys_metadata)
-        self.failUnless('principal' in retr.sys_metadata)
+        self.assertTrue('timestamp' in retr.sys_metadata)
+        self.assertTrue('principal' in retr.sys_metadata)
 
         # check the references
         inside_refs = retr.data.inside_refs
@@ -306,7 +306,7 @@ def test08_retrieveWithReferences(self):
         self.assertEqual(len(outside_refs), 1)
         refs = [ref.getAttribute() for ref in inside_refs+outside_refs]
         for ref in refs:
-            self.failUnless(IVersionAwareReference.providedBy(ref))
+            self.assertTrue(IVersionAwareReference.providedBy(ref))
             # check info value (see note above)
             self.assertEquals(ref.info, refs.index(ref))
 
@@ -317,19 +317,19 @@ def test09_isUpToDate(self):
         prep = portal_archivist.prepare(doc, app_metadata='save number 1')
         v1 = portal_archivist.register(prep)
 
-        self.failUnless(portal_archivist.isUpToDate(obj=doc))
-        self.failUnless(portal_archivist.isUpToDate(obj=doc, selector=v1))
+        self.assertTrue(portal_archivist.isUpToDate(obj=doc))
+        self.assertTrue(portal_archivist.isUpToDate(obj=doc, selector=v1))
 
         doc.text = 'text v2'
         notifyModified(doc)
-        self.failIf(portal_archivist.isUpToDate(obj=doc))
+        self.assertFalse(portal_archivist.isUpToDate(obj=doc))
 
         prep = portal_archivist.prepare(doc, app_metadata='save number 2')
         v2 = portal_archivist.save(prep)
 
-        self.failUnless(portal_archivist.isUpToDate(obj=doc))
-        self.failUnless(portal_archivist.isUpToDate(obj=doc, selector=v2))
-        self.failIf(portal_archivist.isUpToDate(obj=doc, selector=v1))
+        self.assertTrue(portal_archivist.isUpToDate(obj=doc))
+        self.assertTrue(portal_archivist.isUpToDate(obj=doc, selector=v2))
+        self.assertFalse(portal_archivist.isUpToDate(obj=doc, selector=v1))
 
     def test09_getHistoryMetadata(self):
         portal_archivist = self.portal.portal_archivist
@@ -347,8 +347,8 @@ def test09_getHistoryMetadata(self):
 
         self.assertEqual(len(history), 2)
         # check if timestamp and principal available
-        self.failUnless(history.retrieve(1)['metadata']['sys_metadata']['timestamp'])
-        self.failUnless(history.retrieve(0)['metadata']['sys_metadata']['principal'])
+        self.assertTrue(history.retrieve(1)['metadata']['sys_metadata']['timestamp'])
+        self.assertTrue(history.retrieve(0)['metadata']['sys_metadata']['principal'])
         # check if correct data and metadata retrieved
         self.assertEqual(history.retrieve(0)['metadata']['app_metadata'], 'save number 1')
         self.assertEqual(history.retrieve(1)['metadata']['app_metadata'], 'save number 2')
@@ -370,8 +370,8 @@ def test09_getHistoryMetadata_byId(self):
 
         self.assertEqual(len(history), 2)
         # check if timestamp and principal available
-        self.failUnless(history.retrieve(1)['metadata']['sys_metadata']['timestamp'])
-        self.failUnless(history.retrieve(0)['metadata']['sys_metadata']['principal'])
+        self.assertTrue(history.retrieve(1)['metadata']['sys_metadata']['timestamp'])
+        self.assertTrue(history.retrieve(0)['metadata']['sys_metadata']['principal'])
         # check if correct data and metadata retrieved
         self.assertEqual(history.retrieve(0)['metadata']['app_metadata'], 'save number 1')
         self.assertEqual(history.retrieve(1)['metadata']['app_metadata'], 'save number 2')
diff --git a/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py b/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py
index c05f0c1..32ffdde 100644
--- a/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py
+++ b/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py
@@ -161,7 +161,7 @@ def test04_isUptoDate(self):
         self.assertEqual(portal_repository.isUpToDate(doc), True)
         doc.text = 'text v2'
         notifyModified(doc)
-        self.failIf(portal_repository.isUpToDate(doc))
+        self.assertFalse(portal_repository.isUpToDate(doc))
 
     def test05_getHistory(self):
         portal_repository = self.portal.portal_repository
@@ -229,7 +229,7 @@ def test07_restoreDeletedObject(self):
 
         # delete the object we want to retrieve later
         self.portal.manage_delObjects(ids=['doc'])
-        self.failIf('doc' in self.portal.objectIds())
+        self.assertFalse('doc' in self.portal.objectIds())
         self.assertRaises(
             AttributeError,
             portal_repository.restore,
@@ -255,7 +255,7 @@ def test07_restoreDeletedObjectWithNewId(self):
 
         # delete the object we want to retrieve later
         self.portal.manage_delObjects(ids=['doc'])
-        self.failIf('doc' in self.portal.objectIds())
+        self.assertFalse('doc' in self.portal.objectIds())
         self.assertRaises(
             AttributeError,
             portal_repository.restore,
@@ -455,7 +455,7 @@ def test01_remove_policy_from_type(self):
                                                         'at_edit_autoversion'))
         portal_repository.removePolicyFromContentType('Document',
                                                         'at_edit_autoversion')
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                         'at_edit_autoversion'))
 
     def test02_set_policy_on_type(self):
@@ -465,7 +465,7 @@ def test02_set_policy_on_type(self):
                                                         'at_edit_autoversion'))
         portal_repository.removePolicyFromContentType('Document',
                                                         'at_edit_autoversion')
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                         'at_edit_autoversion'))
         portal_repository.addPolicyForContentType('Document',
                                                         'at_edit_autoversion')
@@ -495,9 +495,9 @@ def test03_set_policy_types_map(self):
                                                     'at_edit_autoversion',
                                                     'version_on_publish']})
         portal_repository.manage_setTypePolicies({'Document': []})
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                        'at_edit_autoversion'))
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                        'version_on_publish'))
 
 
@@ -530,7 +530,7 @@ def test05_remove_policy(self):
                                                         'version_on_publish')
         portal_repository.removePolicy('version_on_publish')
         self.assertEqual(len(portal_repository.listPolicies()), self.np)
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                         'version_on_publish'))
 
     def test07_set_policy_defs(self):
@@ -594,7 +594,7 @@ def test09_policy_hooks(self):
         self.assertEqual(out, ['added','enabled Document'])
         portal_repository.removePolicyFromContentType('Document',
                                                    'my_bogus_policy', out=out)
-        self.failIf(portal_repository.supportsPolicy(self.portal.doc,
+        self.assertFalse(portal_repository.supportsPolicy(self.portal.doc,
                                                         'my_bogus_policy'))
         self.assertEqual(out, ['added','enabled Document',
                                                     'disabled Document'])
@@ -653,9 +653,9 @@ def test13_at_auto_version_hooks(self):
                                                      'success', None, None))
         # Remove policy and check if hook is removed
         portal_repository.removePolicy('at_edit_autoversion')
-        self.failIf(self.isFCActionInPlace('validate_integrity',
+        self.assertFalse(self.isFCActionInPlace('validate_integrity',
                                                  'success', None, None))
-        self.failIf(self.isFCActionInPlace('atct_edit',
+        self.assertFalse(self.isFCActionInPlace('atct_edit',
                                                      'success', None, None))
         # Add policy and check if hook is added
         portal_repository.addPolicy('at_edit_autoversion', 'Auto policy',
@@ -673,4 +673,4 @@ def test14_has_policy(self):
                                                         'at_edit_autoversion')
         portal_repository.removePolicyFromContentType('Document',
                                                         'version_on_revert')
-        self.failIf(portal_repository.hasPolicy(self.portal.doc))
+        self.assertFalse(portal_repository.hasPolicy(self.portal.doc))
diff --git a/Products/CMFEditions/tests/test_IntegrationTests.py b/Products/CMFEditions/tests/test_IntegrationTests.py
index 80eee18..e5dd3fb 100644
--- a/Products/CMFEditions/tests/test_IntegrationTests.py
+++ b/Products/CMFEditions/tests/test_IntegrationTests.py
@@ -190,10 +190,10 @@ def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):
         copy = self.portal.copy_of_doc
 
         # the copy shall not have a history yet: that's correct
-        self.failIf(portal_repo.getHistory(copy))
+        self.assertFalse(portal_repo.getHistory(copy))
 
         # just to be sure the history is definitivels different
-        self.failIfEqual(
+        self.assertNotEqual(
             portal_historyidhandler.queryUid(doc),
             portal_historyidhandler.queryUid(copy))  # may be None
 
@@ -333,7 +333,7 @@ def test11_versionAFolderishObjectThatTreatsChildrensAsInsideRefs(self):
         fol = self.portal.fol
         doc1 = fol.doc1
         self.failUnless('doc2' in fol.objectIds())
-        self.failIf('doc3' in fol.objectIds())
+        self.assertFalse('doc3' in fol.objectIds())
         doc2 = fol.doc2
         self.assertEqual(fol.Title(), "v2 of fol")
         self.assertEqual(doc1.Title(), "v2 of doc1")
@@ -678,7 +678,7 @@ def test17_moveInsideRefThenRevertChangesUid(self):
         retrieved_data = portal_repo.retrieve(fol, 0)
         ret_folder = retrieved_data.object
         ret_doc = ret_folder.doc1
-        self.failIf(portal_historyidhandler.queryUid(ret_doc) == orig_uid,
+        self.assertFalse(portal_historyidhandler.queryUid(ret_doc) == orig_uid,
                     "UIDs should not be equal, current value: %s" % orig_uid)
 
         # revert to original state, ensure that subobject changes are
@@ -688,7 +688,7 @@ def test17_moveInsideRefThenRevertChangesUid(self):
         reverted_doc = fol.doc1
 
         # check if reversion worked correctly
-        self.failIf(portal_historyidhandler.queryUid(reverted_doc) == orig_uid,
+        self.assertFalse(portal_historyidhandler.queryUid(reverted_doc) == orig_uid,
                     "UIDs should not be equal, current value: %s" % orig_uid)
 
     def test18_retrieveObjectWhichHasBeenReplaced(self):
@@ -944,7 +944,7 @@ def test21_RestoreMovedObject(self):
         self.assertEqual(len(catalog(Title='v2 of doc1')), 1)
         # The reverted document should have a new uid, because an object with
         # the original uid exists
-        self.failIf(portal_hidhandler.queryUid(res_doc) == history_id)
+        self.assertFalse(portal_hidhandler.queryUid(res_doc) == history_id)
 
     def test22_ParentPointerNotVersionedOrRestored(self):
         portal_repo = self.portal.portal_repository
@@ -1090,7 +1090,7 @@ def test25_versioningRestoresInsideRefsFolderOrder(self):
         # Test that a retrieve uses the order from the repo copy
         repo_fol1 = portal_repo.retrieve(fol, 0).object
         self.failUnlessEqual(fol.objectIds()[0], 'doc2')
-        self.failIfEqual(fol.objectIds(), orig_order)
+        self.assertNotEqual(fol.objectIds(), orig_order)
         self.failUnlessEqual(repo_fol1.objectIds()[0], 'doc1')
 
         # Test that a revert restores the order and objects from the
@@ -1109,7 +1109,7 @@ def test25_versioningRestoresInsideRefsFolderOrder(self):
         doc3 = fol['doc3']
         doc4 = fol['doc4']
 
-        self.failIfEqual(fol.objectIds(), orig_order)
+        self.assertNotEqual(fol.objectIds(), orig_order)
 
         repo_fol1 = portal_repo.retrieve(fol, 0).object
 
@@ -1117,16 +1117,16 @@ def test25_versioningRestoresInsideRefsFolderOrder(self):
         # but does not affect the working copy
         repo_fol1 = portal_repo.retrieve(fol, 0).object
         self.failUnlessEqual(repo_fol1.objectIds(), orig_order)
-        self.failIfEqual(getattr(repo_fol1, 'doc2', None), None)
+        self.assertNotEqual(getattr(repo_fol1, 'doc2', None), None)
         self.failUnlessEqual(getattr(repo_fol1, 'doc5', None), None)
 
-        self.failIfEqual(fol.objectIds(), orig_order)
+        self.assertNotEqual(fol.objectIds(), orig_order)
         self.failUnlessEqual(fol.objectIds()[0], 'doc4')
         self.failUnlessEqual(fol.objectIds()[1], 'doc3')
         self.failUnlessEqual(fol['doc3'], doc3)
         self.failUnlessEqual(fol['doc4'], doc4)
         self.failUnlessEqual(getattr(fol, 'doc2', None), None)
-        self.failIfEqual(getattr(fol, 'doc5', None), None)
+        self.assertNotEqual(getattr(fol, 'doc5', None), None)
 
         # Test that a revert restores the missing child from the repo
         # copy, removed the newly created child and restored the order
diff --git a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
index b0da822..7900345 100644
--- a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
+++ b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
@@ -60,7 +60,7 @@ def test01_beforeSaveHookInfinite(self):
 
         storage.save(history_id=1, obj=DummyData(0))
         res = purgepolicy.beforeSaveHook(history_id=1, obj=2, metadata={})
-        self.failUnless(res)
+        self.assertTrue(res)
         self.assertEqual(len(storage.getHistory(history_id=1)), 1)
 
     def test02_beforeSaveHookKeepsMaximumTwoVersions(self):
@@ -71,20 +71,20 @@ def test02_beforeSaveHookKeepsMaximumTwoVersions(self):
         # call hook explicitely before save (dummy tool doesn't call it,
         # we wan't to do it explicitely)
         res = purgepolicy.beforeSaveHook(history_id=1, obj=2, metadata={})
-        self.failUnless(res)
+        self.assertTrue(res)
         storage.save(history_id=1, obj=DummyData(0))
         self.assertEqual(len(storage.getHistory(history_id=1)), 1)
 
         # call hook explicitely before save (dummy tool doesn't call it,
         # we wan't to do it explicitely)
         res = purgepolicy.beforeSaveHook(history_id=1, obj=2, metadata={})
-        self.failUnless(res)
+        self.assertTrue(res)
         storage.save(history_id=1, obj=DummyData(1))
         self.assertEqual(len(storage.getHistory(history_id=1)), 2)
 
         # check the first saved version was purged
         res = purgepolicy.beforeSaveHook(history_id=1, obj=2, metadata={})
-        self.failUnless(res)
+        self.assertTrue(res)
         storage.save(history_id=1, obj=DummyData(2))
         history = storage.getHistory(history_id=1)
         self.assertEqual(len(history), 2)
diff --git a/Products/CMFEditions/tests/test_ZVCStorageTool.py b/Products/CMFEditions/tests/test_ZVCStorageTool.py
index 70812ba..769ad60 100644
--- a/Products/CMFEditions/tests/test_ZVCStorageTool.py
+++ b/Products/CMFEditions/tests/test_ZVCStorageTool.py
@@ -279,19 +279,19 @@ def test09_retrievePurgedVersionsNoPolicyInstalled(self):
         # ``retrieve`` returns the removed info because there is no purge
         # policy installed
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2)
-        self.failIf(retrieved_obj.isValid())
+        self.assertFalse(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.reason, "purged")
         self.assertEqual(self.getComment(retrieved_obj), "purged v3")
 
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,
                                                 substitute=False)
-        self.failIf(retrieved_obj.isValid())
+        self.assertFalse(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.reason, "purged")
         self.assertEqual(self.getComment(retrieved_obj), "purged v3")
 
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,
                                                 countPurged=False)
-        self.failUnless(retrieved_obj.isValid())
+        self.assertTrue(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.object.text, 'v4 of text')
         self.assertEqual(self.getComment(retrieved_obj), 'saved v4')
 
@@ -318,30 +318,30 @@ def test10_retrievePurgedVersionsWithPolicyInstalled(self):
 
         # ``retrieve`` returns the next older object
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=1)
-        self.failUnless(retrieved_obj.isValid())
+        self.assertTrue(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.object.text, 'v1 of text')
         self.assertEqual(self.getComment(retrieved_obj), 'saved v1')
 
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2)
-        self.failUnless(retrieved_obj.isValid())
+        self.assertTrue(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.object.text, 'v1 of text')
         self.assertEqual(self.getComment(retrieved_obj), 'saved v1')
 
         # ``retrieve`` returns existing object
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=3)
-        self.failUnless(retrieved_obj.isValid())
+        self.assertTrue(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.object.text, 'v4 of text')
         self.assertEqual(self.getComment(retrieved_obj), 'saved v4')
 
         # check with substitute=False: should return the removed info
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=1,
                                                 substitute=False)
-        self.failIf(retrieved_obj.isValid())
+        self.assertFalse(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.reason, "purged")
         self.assertEqual(self.getComment(retrieved_obj), "purged v2")
         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,
                                                 substitute=False)
-        self.failIf(retrieved_obj.isValid())
+        self.assertFalse(retrieved_obj.isValid())
         self.assertEqual(retrieved_obj.object.reason, "purged")
         self.assertEqual(self.getComment(retrieved_obj), "purged v3")
 
@@ -571,7 +571,7 @@ def test15_storageStatistics(self):
                 self.assertEqual(actual[key], value)
             # The actual size is not important and we want robust tests,
             # s. https://github.com/plone/Products.CMFEditions/issues/31
-            self.failUnless(actual['size'] > 0)
+            self.assertTrue(actual['size'] > 0)
 
     def test16_delete_history_on_content_deletion(self):
         """ If a content item gets deleted, delete it's history


